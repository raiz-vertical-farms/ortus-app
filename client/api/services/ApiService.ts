/**
 * This file was auto-generated by @openapi-qraft/cli.
 * Do not make direct changes to the file.
 */

import type { paths } from "../schema";
import type { DeepReadonly, InvalidateQueryFilters, MutationFiltersByMutationKey, MutationFiltersByParameters, MutationVariables, OperationError, OperationInfiniteData, PartialParameters, QueryFiltersByParameters, QueryFiltersByQueryKey, QueryFnOptionsByParameters, QueryFnOptionsByQueryKey, RequestFnResponse, ServiceOperationEnsureInfiniteQueryDataOptions, ServiceOperationEnsureQueryDataOptions, ServiceOperationFetchInfiniteQueryOptions, ServiceOperationFetchQueryOptions, ServiceOperationInfiniteQueryKey, ServiceOperationMutationFnOptions, ServiceOperationMutationKey, ServiceOperationQueryKey, ServiceOperationUseMutationOptions, UseQueryOptionsForUseQueries, UseQueryOptionsForUseSuspenseQuery, WithOptional, QraftServiceOperationsToken } from "@openapi-qraft/tanstack-query-react-types";
import type { CancelOptions, DefinedInitialDataInfiniteOptions, DefinedInitialDataOptions, DefinedUseInfiniteQueryResult, DefinedUseQueryResult, InfiniteQueryPageParamsOptions, InvalidateOptions, Mutation, MutationCache, MutationState, NoInfer, QueryState, RefetchOptions, ResetOptions, SetDataOptions, UndefinedInitialDataInfiniteOptions, UndefinedInitialDataOptions, Updater, UseInfiniteQueryResult, UseMutationResult, UseQueryResult, UseSuspenseInfiniteQueryOptions, UseSuspenseInfiniteQueryResult, UseSuspenseQueryOptions, UseSuspenseQueryResult } from "@tanstack/react-query";
export interface ApiService {
    /** @summary Register a new device */
    createDevice: {
        /** @summary Register a new device */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<CreateDeviceBody, CreateDeviceParameters, TMeta, TSignal>, client?: (schema: CreateDeviceSchema, options: ServiceOperationMutationFnOptions<CreateDeviceBody, CreateDeviceParameters, TMeta, TSignal>) => Promise<RequestFnResponse<CreateDeviceData, CreateDeviceError>>): Promise<RequestFnResponse<CreateDeviceData, CreateDeviceError>>;
        /** @summary Register a new device */
        getMutationKey(parameters: DeepReadonly<CreateDeviceParameters> | void): ServiceOperationMutationKey<CreateDeviceSchema, CreateDeviceParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Register a new device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.createDevice.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.createDevice.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends CreateDeviceBody, TContext = unknown>(parameters: DeepReadonly<CreateDeviceParameters>, options?: ServiceOperationUseMutationOptions<CreateDeviceSchema, CreateDeviceData, CreateDeviceParameters, TVariables, OperationError<CreateDeviceError>, TContext>): UseMutationResult<CreateDeviceData, OperationError<CreateDeviceError>, TVariables | void, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Register a new device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.createDevice.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.createDevice.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<CreateDeviceBody, CreateDeviceParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<CreateDeviceSchema, CreateDeviceData, CreateDeviceParameters, TVariables, OperationError<CreateDeviceError>, TContext>): UseMutationResult<CreateDeviceData, OperationError<CreateDeviceError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Register a new device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const createDeviceTotal = qraft.apiService.createDevice.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const createDeviceTotal = qraft.apiService.createDevice.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<CreateDeviceBody, CreateDeviceData, CreateDeviceParameters, OperationError<CreateDeviceError>, TContext> | MutationFiltersByMutationKey<CreateDeviceSchema, CreateDeviceBody, CreateDeviceData, CreateDeviceParameters, OperationError<CreateDeviceError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Register a new device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const createDevicePendingMutationVariables = qraft.apiService.createDevice.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const createDeviceMutationData = qraft.apiService.createDevice.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<CreateDeviceData, OperationError<CreateDeviceError>, MutationVariables<CreateDeviceBody, CreateDeviceParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<CreateDeviceBody, CreateDeviceData, CreateDeviceParameters, OperationError<CreateDeviceError>, TContext> | MutationFiltersByMutationKey<CreateDeviceSchema, CreateDeviceBody, CreateDeviceData, CreateDeviceParameters, OperationError<CreateDeviceError>, TContext>;
            select?: (mutation: Mutation<CreateDeviceData, OperationError<CreateDeviceError>, MutationVariables<CreateDeviceBody, CreateDeviceParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /** @summary Register a new device */
        isMutating<TContext>(filters?: MutationFiltersByParameters<CreateDeviceBody, CreateDeviceData, CreateDeviceParameters, OperationError<CreateDeviceError>, TContext> | MutationFiltersByMutationKey<CreateDeviceSchema, CreateDeviceBody, CreateDeviceData, CreateDeviceParameters, OperationError<CreateDeviceError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Register a new device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.apiService.createDevice.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {}
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.apiService.createDevice.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<CreateDeviceBody, CreateDeviceData, CreateDeviceParameters, OperationError<CreateDeviceError>, TContext> | MutationFiltersByMutationKey<CreateDeviceSchema, CreateDeviceBody, CreateDeviceData, CreateDeviceParameters, OperationError<CreateDeviceError>, TContext>): Mutation<CreateDeviceData, CreateDeviceError, MutationVariables<CreateDeviceBody, CreateDeviceParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<CreateDeviceBody, CreateDeviceData, CreateDeviceParameters, OperationError<CreateDeviceError>, TContext> | MutationFiltersByMutationKey<CreateDeviceSchema, CreateDeviceBody, CreateDeviceData, CreateDeviceParameters, OperationError<CreateDeviceError>, TContext>): Array<Mutation<CreateDeviceData, CreateDeviceError, MutationVariables<CreateDeviceBody, CreateDeviceParameters>, TContext>>;
        };
        schema: CreateDeviceSchema;
        types: {
            parameters: CreateDeviceParameters;
            data: CreateDeviceData;
            error: CreateDeviceError;
            body: CreateDeviceBody;
        };
    };
    /** @summary Delete a device */
    deleteDevice: {
        /** @summary Delete a device */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<DeleteDeviceBody, DeleteDeviceParameters, TMeta, TSignal>, client?: (schema: DeleteDeviceSchema, options: ServiceOperationMutationFnOptions<DeleteDeviceBody, DeleteDeviceParameters, TMeta, TSignal>) => Promise<RequestFnResponse<DeleteDeviceData, DeleteDeviceError>>): Promise<RequestFnResponse<DeleteDeviceData, DeleteDeviceError>>;
        /** @summary Delete a device */
        getMutationKey(parameters: DeepReadonly<DeleteDeviceParameters> | void): ServiceOperationMutationKey<DeleteDeviceSchema, DeleteDeviceParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Delete a device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.deleteDevice.useMutation({
         *     path: {
         *         id: id
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.deleteDevice.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         id: id
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends DeleteDeviceBody, TContext = unknown>(parameters: DeepReadonly<DeleteDeviceParameters>, options?: ServiceOperationUseMutationOptions<DeleteDeviceSchema, DeleteDeviceData, DeleteDeviceParameters, TVariables, OperationError<DeleteDeviceError>, TContext>): UseMutationResult<DeleteDeviceData, OperationError<DeleteDeviceError>, TVariables | void, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Delete a device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.deleteDevice.useMutation({
         *     path: {
         *         id: id
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.deleteDevice.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         id: id
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<DeleteDeviceBody, DeleteDeviceParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<DeleteDeviceSchema, DeleteDeviceData, DeleteDeviceParameters, TVariables, OperationError<DeleteDeviceError>, TContext>): UseMutationResult<DeleteDeviceData, OperationError<DeleteDeviceError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Delete a device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const deleteDeviceTotal = qraft.apiService.deleteDevice.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const deleteDeviceTotal = qraft.apiService.deleteDevice.useIsMutating({
         *     parameters: {
         *         path: {
         *             id: id
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<DeleteDeviceBody, DeleteDeviceData, DeleteDeviceParameters, OperationError<DeleteDeviceError>, TContext> | MutationFiltersByMutationKey<DeleteDeviceSchema, DeleteDeviceBody, DeleteDeviceData, DeleteDeviceParameters, OperationError<DeleteDeviceError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Delete a device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const deleteDevicePendingMutationVariables = qraft.apiService.deleteDevice.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const deleteDeviceMutationData = qraft.apiService.deleteDevice.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 id: id
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<DeleteDeviceData, OperationError<DeleteDeviceError>, MutationVariables<DeleteDeviceBody, DeleteDeviceParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<DeleteDeviceBody, DeleteDeviceData, DeleteDeviceParameters, OperationError<DeleteDeviceError>, TContext> | MutationFiltersByMutationKey<DeleteDeviceSchema, DeleteDeviceBody, DeleteDeviceData, DeleteDeviceParameters, OperationError<DeleteDeviceError>, TContext>;
            select?: (mutation: Mutation<DeleteDeviceData, OperationError<DeleteDeviceError>, MutationVariables<DeleteDeviceBody, DeleteDeviceParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /** @summary Delete a device */
        isMutating<TContext>(filters?: MutationFiltersByParameters<DeleteDeviceBody, DeleteDeviceData, DeleteDeviceParameters, OperationError<DeleteDeviceError>, TContext> | MutationFiltersByMutationKey<DeleteDeviceSchema, DeleteDeviceBody, DeleteDeviceData, DeleteDeviceParameters, OperationError<DeleteDeviceError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Delete a device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.apiService.deleteDevice.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {
         *         path: {
         *             id: id
         *         }
         *     }
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.apiService.deleteDevice.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<DeleteDeviceBody, DeleteDeviceData, DeleteDeviceParameters, OperationError<DeleteDeviceError>, TContext> | MutationFiltersByMutationKey<DeleteDeviceSchema, DeleteDeviceBody, DeleteDeviceData, DeleteDeviceParameters, OperationError<DeleteDeviceError>, TContext>): Mutation<DeleteDeviceData, DeleteDeviceError, MutationVariables<DeleteDeviceBody, DeleteDeviceParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<DeleteDeviceBody, DeleteDeviceData, DeleteDeviceParameters, OperationError<DeleteDeviceError>, TContext> | MutationFiltersByMutationKey<DeleteDeviceSchema, DeleteDeviceBody, DeleteDeviceData, DeleteDeviceParameters, OperationError<DeleteDeviceError>, TContext>): Array<Mutation<DeleteDeviceData, DeleteDeviceError, MutationVariables<DeleteDeviceBody, DeleteDeviceParameters>, TContext>>;
        };
        schema: DeleteDeviceSchema;
        types: {
            parameters: DeleteDeviceParameters;
            data: DeleteDeviceData;
            error: DeleteDeviceError;
            body: DeleteDeviceBody;
        };
    };
    /** @summary Retrieve the latest state for a specific device */
    deviceState: {
        /** @summary Retrieve the latest state for a specific device */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<DeviceStateSchema, DeviceStateParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<DeviceStateParameters, TMeta, TSignal>), client?: (schema: DeviceStateSchema, options: {
            parameters: DeviceStateParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<DeviceStateData, DeviceStateError>>): Promise<RequestFnResponse<DeviceStateData, DeviceStateError>>;
        /** @summary Retrieve the latest state for a specific device */
        getQueryKey(parameters: DeepReadonly<DeviceStateParameters>): ServiceOperationQueryKey<DeviceStateSchema, DeviceStateParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Retrieve the latest state for a specific device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.deviceState.useQuery({
         *     path: {
         *         id: id
         *     }
         * })
         * ```
         */
        useQuery<TData = DeviceStateData>(parameters: ServiceOperationQueryKey<DeviceStateSchema, DeviceStateParameters> | (DeepReadonly<DeviceStateParameters>), options?: Omit<UndefinedInitialDataOptions<DeviceStateData, DeviceStateError, TData, ServiceOperationQueryKey<DeviceStateSchema, DeviceStateParameters>>, "queryKey">): UseQueryResult<TData, OperationError<DeviceStateError>>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Retrieve the latest state for a specific device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.deviceState.useQuery({
         *     path: {
         *         id: id
         *     }
         * })
         * ```
         */
        useQuery<TData = DeviceStateData>(parameters: ServiceOperationQueryKey<DeviceStateSchema, DeviceStateParameters> | (DeepReadonly<DeviceStateParameters>), options: Omit<DefinedInitialDataOptions<DeviceStateData, DeviceStateError, TData, ServiceOperationQueryKey<DeviceStateSchema, DeviceStateParameters>>, "queryKey">): DefinedUseQueryResult<TData, OperationError<DeviceStateError>>;
        /** @summary Retrieve the latest state for a specific device */
        getInfiniteQueryKey(parameters: DeepReadonly<DeviceStateParameters>): ServiceOperationInfiniteQueryKey<DeviceStateSchema, DeviceStateParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Retrieve the latest state for a specific device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.deviceState.useInfiniteQuery({
         *     path: {
         *         id: id
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends DeviceStateParameters, TQueryFnData = DeviceStateData, TData = OperationInfiniteData<TQueryFnData, DeviceStateParameters>>(parameters: ServiceOperationInfiniteQueryKey<DeviceStateSchema, DeviceStateParameters> | (DeepReadonly<DeviceStateParameters>), options: Omit<UndefinedInitialDataInfiniteOptions<TQueryFnData, DeviceStateError, TData, ServiceOperationInfiniteQueryKey<DeviceStateSchema, DeviceStateParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>): UseInfiniteQueryResult<TData, OperationError<DeviceStateError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Retrieve the latest state for a specific device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.deviceState.useInfiniteQuery({
         *     path: {
         *         id: id
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends DeviceStateParameters, TQueryFnData = DeviceStateData, TData = OperationInfiniteData<TQueryFnData, DeviceStateParameters>>(parameters: ServiceOperationInfiniteQueryKey<DeviceStateSchema, DeviceStateParameters> | (DeepReadonly<DeviceStateParameters>), options: Omit<DefinedInitialDataInfiniteOptions<TQueryFnData, DeviceStateError, TData, ServiceOperationInfiniteQueryKey<DeviceStateSchema, DeviceStateParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<DeviceStateData, PartialParameters<DeepReadonly<TPageParam>>>): DefinedUseInfiniteQueryResult<TData, OperationError<DeviceStateError>>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @summary Retrieve the latest state for a specific device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const deviceStateTotal = qraft.apiService.deviceState.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const deviceStateByParametersTotal = qraft.apiService.deviceState.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         path: {
         *             id: id
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError> | QueryFiltersByQueryKey<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary Retrieve the latest state for a specific device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const deviceStateResults = qraft.apiService.deviceState.useQueries({
         *     queries: [
         *         {
         *             path: {
         *                 id: id1
         *             }
         *         },
         *         {
         *             path: {
         *                 id: id2
         *             }
         *         }
         *     ]
         * });
         * deviceStateResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const deviceStateCombinedResults = qraft.apiService.deviceState.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             path: {
         *                 id: id1
         *             }
         *         },
         *         {
         *             path: {
         *                 id: id2
         *             }
         *         }
         *     ]
         * });
         * deviceStateCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<DeviceStateSchema, DeviceStateParameters, DeviceStateData, DeviceStateError>>, TCombinedResult = Array<UseQueryResult<DeviceStateData, DeviceStateError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<DeviceStateData, DeviceStateError>>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * Performs asynchronous data fetching with Suspense support.
         * Similar to useQuery but integrates with React Suspense for loading states.
         *
         * @summary Retrieve the latest state for a specific device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
         * @example Suspense Query with parameters
         * ```ts
         * const data = qraft.apiService.deviceState.useSuspenseQuery({
         *     path: {
         *         id: id
         *     }
         * })
         * ```
         */
        useSuspenseQuery<TData = DeviceStateData>(parameters: ServiceOperationQueryKey<DeviceStateSchema, DeviceStateParameters> | (DeepReadonly<DeviceStateParameters>), options?: Omit<UseSuspenseQueryOptions<DeviceStateData, DeviceStateError, TData, ServiceOperationQueryKey<DeviceStateSchema, DeviceStateParameters>>, "queryKey">): UseSuspenseQueryResult<TData, OperationError<DeviceStateError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @summary Retrieve the latest state for a specific device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.deviceState.useSuspenseInfiniteQuery({
         *     path: {
         *         id: id
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends DeviceStateParameters, TData = DeviceStateData>(parameters: ServiceOperationInfiniteQueryKey<DeviceStateSchema, DeviceStateParameters> | (DeepReadonly<DeviceStateParameters>), options: Omit<UseSuspenseInfiniteQueryOptions<DeviceStateData, DeviceStateError, OperationInfiniteData<TData, DeviceStateParameters>, ServiceOperationInfiniteQueryKey<DeviceStateSchema, DeviceStateParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<DeviceStateData, PartialParameters<DeepReadonly<TPageParam>>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, DeviceStateParameters>, OperationError<DeviceStateError>>;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
         * Similar to useQueries but integrates with React Suspense for loading states.
         *
         * @summary Retrieve the latest state for a specific device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
         * @example Basic usage with Suspense
         * ```ts
         * const deviceStateData = qraft.apiService.deviceState.useSuspenseQueries({
         *     queries: [
         *         {
         *             path: {
         *                 id: id1
         *             }
         *         },
         *         {
         *             path: {
         *                 id: id2
         *             }
         *         }
         *     ]
         * });
         * deviceStateResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example With data transformation using combine
         * ```ts
         * const deviceStateCombinedData = qraft.apiService.deviceState.useSuspenseQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             path: {
         *                 id: id1
         *             }
         *         },
         *         {
         *             path: {
         *                 id: id2
         *             }
         *         }
         *     ]
         * });
         * deviceStateCombinedData.forEach(data => console.log({ data }));
         * ```
         */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<DeviceStateSchema, DeviceStateParameters, DeviceStateData, DeviceStateError>>, TCombinedResult = Array<UseSuspenseQueryResult<DeviceStateData, DeviceStateError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<DeviceStateData, DeviceStateError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /** @summary Retrieve the latest state for a specific device */
        fetchQuery(options: ServiceOperationFetchQueryOptions<DeviceStateSchema, DeviceStateData, DeviceStateParameters, DeviceStateError>): Promise<DeviceStateData>;
        /** @summary Retrieve the latest state for a specific device */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<DeviceStateSchema, DeviceStateData, DeviceStateParameters, DeviceStateError>): Promise<void>;
        /** @summary Retrieve the latest state for a specific device */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<DeviceStateSchema, DeviceStateData, DeviceStateParameters, DeviceStateError>): Promise<DeviceStateData>;
        /** @summary Retrieve the latest state for a specific device */
        fetchInfiniteQuery<TPageParam extends DeviceStateParameters>(options: ServiceOperationFetchInfiniteQueryOptions<DeviceStateSchema, DeviceStateData, DeviceStateParameters, DeepReadonly<TPageParam>, DeviceStateError>): Promise<OperationInfiniteData<DeviceStateData, DeviceStateParameters>>;
        /** @summary Retrieve the latest state for a specific device */
        prefetchInfiniteQuery<TPageParam extends DeviceStateParameters>(options: ServiceOperationFetchInfiniteQueryOptions<DeviceStateSchema, DeviceStateData, DeviceStateParameters, DeepReadonly<TPageParam>, DeviceStateError>): Promise<void>;
        /** @summary Retrieve the latest state for a specific device */
        ensureInfiniteQueryData<TPageParam extends DeviceStateParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<DeviceStateSchema, DeviceStateData, DeviceStateParameters, DeepReadonly<TPageParam>, DeviceStateError>): Promise<OperationInfiniteData<DeviceStateData, DeviceStateParameters>>;
        /** @summary Retrieve the latest state for a specific device */
        getQueryData(parameters: ServiceOperationQueryKey<DeviceStateSchema, DeviceStateParameters> | (DeepReadonly<DeviceStateParameters>)): DeviceStateData | undefined;
        /** @summary Retrieve the latest state for a specific device */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<DeviceStateSchema, DeviceStateParameters> | (DeepReadonly<DeviceStateParameters>)): OperationInfiniteData<DeviceStateData, DeviceStateParameters> | undefined;
        /** @summary Retrieve the latest state for a specific device */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError> | QueryFiltersByQueryKey<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<DeviceStateSchema, DeviceStateParameters>,
            data: NoInfer<OperationInfiniteData<DeviceStateData, DeviceStateParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<DeviceStateSchema, DeviceStateParameters>,
            data: DeviceStateData | undefined
        ]>;
        /** @summary Retrieve the latest state for a specific device */
        getQueryState(parameters: ServiceOperationQueryKey<DeviceStateSchema, DeviceStateParameters> | (DeepReadonly<DeviceStateParameters>)): QueryState<DeviceStateData, DeviceStateError> | undefined;
        /** @summary Retrieve the latest state for a specific device */
        getInfiniteQueryState(parameters: DeepReadonly<DeviceStateParameters> | ServiceOperationInfiniteQueryKey<DeviceStateSchema, DeviceStateParameters>): QueryState<OperationInfiniteData<DeviceStateData, DeviceStateParameters>, DeviceStateError> | undefined;
        /** @summary Retrieve the latest state for a specific device */
        setQueryData(parameters: (DeepReadonly<DeviceStateParameters>) | ServiceOperationQueryKey<DeviceStateSchema, DeviceStateParameters>, updater: Updater<NoInfer<DeviceStateData> | undefined, NoInfer<DeepReadonly<DeviceStateData>> | undefined>, options?: SetDataOptions): DeviceStateData | undefined;
        /** @summary Retrieve the latest state for a specific device */
        setInfiniteQueryData(parameters: (DeepReadonly<DeviceStateParameters>) | ServiceOperationInfiniteQueryKey<DeviceStateSchema, DeviceStateParameters>, updater: Updater<NoInfer<OperationInfiniteData<DeviceStateData, DeviceStateParameters>> | undefined, NoInfer<DeepReadonly<OperationInfiniteData<DeviceStateData, DeviceStateParameters>>> | undefined>, options?: SetDataOptions): OperationInfiniteData<DeviceStateData, DeviceStateParameters> | undefined;
        /** @summary Retrieve the latest state for a specific device */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError> | QueryFiltersByQueryKey<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError>, updater: Updater<NoInfer<DeviceStateData> | undefined, NoInfer<DeviceStateData> | undefined>, options?: SetDataOptions): Array<DeviceStateData | undefined>;
        /** @summary Retrieve the latest state for a specific device */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError>, options?: InvalidateOptions): Promise<void>;
        /** @summary Retrieve the latest state for a specific device */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError> | QueryFiltersByQueryKey<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError>, options?: RefetchOptions): Promise<void>;
        /** @summary Retrieve the latest state for a specific device */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError> | QueryFiltersByQueryKey<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError>, options?: CancelOptions): Promise<void>;
        /** @summary Retrieve the latest state for a specific device */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError> | QueryFiltersByQueryKey<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError>): void;
        /** @summary Retrieve the latest state for a specific device */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError> | QueryFiltersByQueryKey<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError>, options?: ResetOptions): Promise<void>;
        /** @summary Retrieve the latest state for a specific device */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError> | QueryFiltersByQueryKey<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError>): number;
        schema: DeviceStateSchema;
        types: {
            parameters: DeviceStateParameters;
            data: DeviceStateData;
            error: DeviceStateError;
        };
    };
    /** @summary List devices */
    allDevices: {
        /** @summary List devices */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<AllDevicesSchema, AllDevicesParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<AllDevicesParameters, TMeta, TSignal> | void), client?: (schema: AllDevicesSchema, options: {
            parameters: AllDevicesParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<AllDevicesData, AllDevicesError>>): Promise<RequestFnResponse<AllDevicesData, AllDevicesError>>;
        /** @summary List devices */
        getQueryKey(parameters: DeepReadonly<AllDevicesParameters> | void): ServiceOperationQueryKey<AllDevicesSchema, AllDevicesParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary List devices
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.allDevices.useQuery()
         * ```
         */
        useQuery<TData = AllDevicesData>(parameters: ServiceOperationQueryKey<AllDevicesSchema, AllDevicesParameters> | (DeepReadonly<AllDevicesParameters> | void), options?: Omit<UndefinedInitialDataOptions<AllDevicesData, AllDevicesError, TData, ServiceOperationQueryKey<AllDevicesSchema, AllDevicesParameters>>, "queryKey">): UseQueryResult<TData, OperationError<AllDevicesError>>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary List devices
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.allDevices.useQuery()
         * ```
         */
        useQuery<TData = AllDevicesData>(parameters: ServiceOperationQueryKey<AllDevicesSchema, AllDevicesParameters> | (DeepReadonly<AllDevicesParameters> | void), options: Omit<DefinedInitialDataOptions<AllDevicesData, AllDevicesError, TData, ServiceOperationQueryKey<AllDevicesSchema, AllDevicesParameters>>, "queryKey">): DefinedUseQueryResult<TData, OperationError<AllDevicesError>>;
        /** @summary List devices */
        getInfiniteQueryKey(parameters: DeepReadonly<AllDevicesParameters> | void): ServiceOperationInfiniteQueryKey<AllDevicesSchema, AllDevicesParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary List devices
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.allDevices.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends AllDevicesParameters, TQueryFnData = AllDevicesData, TData = OperationInfiniteData<TQueryFnData, AllDevicesParameters>>(parameters: ServiceOperationInfiniteQueryKey<AllDevicesSchema, AllDevicesParameters> | (DeepReadonly<AllDevicesParameters> | void), options: Omit<UndefinedInitialDataInfiniteOptions<TQueryFnData, AllDevicesError, TData, ServiceOperationInfiniteQueryKey<AllDevicesSchema, AllDevicesParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>): UseInfiniteQueryResult<TData, OperationError<AllDevicesError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary List devices
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.allDevices.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends AllDevicesParameters, TQueryFnData = AllDevicesData, TData = OperationInfiniteData<TQueryFnData, AllDevicesParameters>>(parameters: ServiceOperationInfiniteQueryKey<AllDevicesSchema, AllDevicesParameters> | (DeepReadonly<AllDevicesParameters> | void), options: Omit<DefinedInitialDataInfiniteOptions<TQueryFnData, AllDevicesError, TData, ServiceOperationInfiniteQueryKey<AllDevicesSchema, AllDevicesParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<AllDevicesData, PartialParameters<DeepReadonly<TPageParam>>>): DefinedUseInfiniteQueryResult<TData, OperationError<AllDevicesError>>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @summary List devices
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const allDevicesTotal = qraft.apiService.allDevices.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError> | QueryFiltersByQueryKey<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary List devices
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const allDevicesResults = qraft.apiService.allDevices.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * allDevicesResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const allDevicesCombinedResults = qraft.apiService.allDevices.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * allDevicesCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<AllDevicesSchema, AllDevicesParameters, AllDevicesData, AllDevicesError>>, TCombinedResult = Array<UseQueryResult<AllDevicesData, AllDevicesError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<AllDevicesData, AllDevicesError>>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * Performs asynchronous data fetching with Suspense support.
         * Similar to useQuery but integrates with React Suspense for loading states.
         *
         * @summary List devices
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
         * @example Suspense Query without parameters
         * ```ts
         * const data = qraft.apiService.allDevices.useSuspenseQuery()
         * ```
         */
        useSuspenseQuery<TData = AllDevicesData>(parameters: ServiceOperationQueryKey<AllDevicesSchema, AllDevicesParameters> | (DeepReadonly<AllDevicesParameters> | void), options?: Omit<UseSuspenseQueryOptions<AllDevicesData, AllDevicesError, TData, ServiceOperationQueryKey<AllDevicesSchema, AllDevicesParameters>>, "queryKey">): UseSuspenseQueryResult<TData, OperationError<AllDevicesError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @summary List devices
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.allDevices.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends AllDevicesParameters, TData = AllDevicesData>(parameters: ServiceOperationInfiniteQueryKey<AllDevicesSchema, AllDevicesParameters> | (DeepReadonly<AllDevicesParameters> | void), options: Omit<UseSuspenseInfiniteQueryOptions<AllDevicesData, AllDevicesError, OperationInfiniteData<TData, AllDevicesParameters>, ServiceOperationInfiniteQueryKey<AllDevicesSchema, AllDevicesParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<AllDevicesData, PartialParameters<DeepReadonly<TPageParam>>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, AllDevicesParameters>, OperationError<AllDevicesError>>;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
         * Similar to useQueries but integrates with React Suspense for loading states.
         *
         * @summary List devices
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
         * @example Basic usage with Suspense
         * ```ts
         * const allDevicesData = qraft.apiService.allDevices.useSuspenseQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * allDevicesResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example With data transformation using combine
         * ```ts
         * const allDevicesCombinedData = qraft.apiService.allDevices.useSuspenseQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * allDevicesCombinedData.forEach(data => console.log({ data }));
         * ```
         */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<AllDevicesSchema, AllDevicesParameters, AllDevicesData, AllDevicesError>>, TCombinedResult = Array<UseSuspenseQueryResult<AllDevicesData, AllDevicesError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<AllDevicesData, AllDevicesError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /** @summary List devices */
        fetchQuery(options: ServiceOperationFetchQueryOptions<AllDevicesSchema, AllDevicesData, AllDevicesParameters, AllDevicesError> | void): Promise<AllDevicesData>;
        /** @summary List devices */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<AllDevicesSchema, AllDevicesData, AllDevicesParameters, AllDevicesError> | void): Promise<void>;
        /** @summary List devices */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<AllDevicesSchema, AllDevicesData, AllDevicesParameters, AllDevicesError> | void): Promise<AllDevicesData>;
        /** @summary List devices */
        fetchInfiniteQuery<TPageParam extends AllDevicesParameters>(options: ServiceOperationFetchInfiniteQueryOptions<AllDevicesSchema, AllDevicesData, AllDevicesParameters, DeepReadonly<TPageParam>, AllDevicesError> | void): Promise<OperationInfiniteData<AllDevicesData, AllDevicesParameters>>;
        /** @summary List devices */
        prefetchInfiniteQuery<TPageParam extends AllDevicesParameters>(options: ServiceOperationFetchInfiniteQueryOptions<AllDevicesSchema, AllDevicesData, AllDevicesParameters, DeepReadonly<TPageParam>, AllDevicesError> | void): Promise<void>;
        /** @summary List devices */
        ensureInfiniteQueryData<TPageParam extends AllDevicesParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<AllDevicesSchema, AllDevicesData, AllDevicesParameters, DeepReadonly<TPageParam>, AllDevicesError> | void): Promise<OperationInfiniteData<AllDevicesData, AllDevicesParameters>>;
        /** @summary List devices */
        getQueryData(parameters: ServiceOperationQueryKey<AllDevicesSchema, AllDevicesParameters> | (DeepReadonly<AllDevicesParameters> | void)): AllDevicesData | undefined;
        /** @summary List devices */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<AllDevicesSchema, AllDevicesParameters> | (DeepReadonly<AllDevicesParameters> | void)): OperationInfiniteData<AllDevicesData, AllDevicesParameters> | undefined;
        /** @summary List devices */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError> | QueryFiltersByQueryKey<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<AllDevicesSchema, AllDevicesParameters>,
            data: NoInfer<OperationInfiniteData<AllDevicesData, AllDevicesParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<AllDevicesSchema, AllDevicesParameters>,
            data: AllDevicesData | undefined
        ]>;
        /** @summary List devices */
        getQueryState(parameters: ServiceOperationQueryKey<AllDevicesSchema, AllDevicesParameters> | (DeepReadonly<AllDevicesParameters> | void)): QueryState<AllDevicesData, AllDevicesError> | undefined;
        /** @summary List devices */
        getInfiniteQueryState(parameters: DeepReadonly<AllDevicesParameters> | ServiceOperationInfiniteQueryKey<AllDevicesSchema, AllDevicesParameters> | void): QueryState<OperationInfiniteData<AllDevicesData, AllDevicesParameters>, AllDevicesError> | undefined;
        /** @summary List devices */
        setQueryData(parameters: (DeepReadonly<AllDevicesParameters> | undefined) | ServiceOperationQueryKey<AllDevicesSchema, AllDevicesParameters>, updater: Updater<NoInfer<AllDevicesData> | undefined, NoInfer<DeepReadonly<AllDevicesData>> | undefined>, options?: SetDataOptions): AllDevicesData | undefined;
        /** @summary List devices */
        setInfiniteQueryData(parameters: (DeepReadonly<AllDevicesParameters> | undefined) | ServiceOperationInfiniteQueryKey<AllDevicesSchema, AllDevicesParameters>, updater: Updater<NoInfer<OperationInfiniteData<AllDevicesData, AllDevicesParameters>> | undefined, NoInfer<DeepReadonly<OperationInfiniteData<AllDevicesData, AllDevicesParameters>>> | undefined>, options?: SetDataOptions): OperationInfiniteData<AllDevicesData, AllDevicesParameters> | undefined;
        /** @summary List devices */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError> | QueryFiltersByQueryKey<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError>, updater: Updater<NoInfer<AllDevicesData> | undefined, NoInfer<AllDevicesData> | undefined>, options?: SetDataOptions): Array<AllDevicesData | undefined>;
        /** @summary List devices */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError>, options?: InvalidateOptions): Promise<void>;
        /** @summary List devices */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError> | QueryFiltersByQueryKey<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError>, options?: RefetchOptions): Promise<void>;
        /** @summary List devices */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError> | QueryFiltersByQueryKey<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError>, options?: CancelOptions): Promise<void>;
        /** @summary List devices */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError> | QueryFiltersByQueryKey<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError>): void;
        /** @summary List devices */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError> | QueryFiltersByQueryKey<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError>, options?: ResetOptions): Promise<void>;
        /** @summary List devices */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError> | QueryFiltersByQueryKey<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError>): number;
        schema: AllDevicesSchema;
        types: {
            parameters: AllDevicesParameters;
            data: AllDevicesData;
            error: AllDevicesError;
        };
    };
    /** @summary Adjust the the brightness of the light */
    setBrightness: {
        /** @summary Adjust the the brightness of the light */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<SetBrightnessBody, SetBrightnessParameters, TMeta, TSignal>, client?: (schema: SetBrightnessSchema, options: ServiceOperationMutationFnOptions<SetBrightnessBody, SetBrightnessParameters, TMeta, TSignal>) => Promise<RequestFnResponse<SetBrightnessData, SetBrightnessError>>): Promise<RequestFnResponse<SetBrightnessData, SetBrightnessError>>;
        /** @summary Adjust the the brightness of the light */
        getMutationKey(parameters: DeepReadonly<SetBrightnessParameters> | void): ServiceOperationMutationKey<SetBrightnessSchema, SetBrightnessParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Adjust the the brightness of the light
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.setBrightness.useMutation({
         *     path: {
         *         id: id
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.setBrightness.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         id: id
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends SetBrightnessBody, TContext = unknown>(parameters: DeepReadonly<SetBrightnessParameters>, options?: ServiceOperationUseMutationOptions<SetBrightnessSchema, SetBrightnessData, SetBrightnessParameters, TVariables, OperationError<SetBrightnessError>, TContext>): UseMutationResult<SetBrightnessData, OperationError<SetBrightnessError>, TVariables | void, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Adjust the the brightness of the light
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.setBrightness.useMutation({
         *     path: {
         *         id: id
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.setBrightness.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         id: id
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<SetBrightnessBody, SetBrightnessParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<SetBrightnessSchema, SetBrightnessData, SetBrightnessParameters, TVariables, OperationError<SetBrightnessError>, TContext>): UseMutationResult<SetBrightnessData, OperationError<SetBrightnessError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Adjust the the brightness of the light
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const setBrightnessTotal = qraft.apiService.setBrightness.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const setBrightnessTotal = qraft.apiService.setBrightness.useIsMutating({
         *     parameters: {
         *         path: {
         *             id: id
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<SetBrightnessBody, SetBrightnessData, SetBrightnessParameters, OperationError<SetBrightnessError>, TContext> | MutationFiltersByMutationKey<SetBrightnessSchema, SetBrightnessBody, SetBrightnessData, SetBrightnessParameters, OperationError<SetBrightnessError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Adjust the the brightness of the light
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const setBrightnessPendingMutationVariables = qraft.apiService.setBrightness.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const setBrightnessMutationData = qraft.apiService.setBrightness.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 id: id
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<SetBrightnessData, OperationError<SetBrightnessError>, MutationVariables<SetBrightnessBody, SetBrightnessParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<SetBrightnessBody, SetBrightnessData, SetBrightnessParameters, OperationError<SetBrightnessError>, TContext> | MutationFiltersByMutationKey<SetBrightnessSchema, SetBrightnessBody, SetBrightnessData, SetBrightnessParameters, OperationError<SetBrightnessError>, TContext>;
            select?: (mutation: Mutation<SetBrightnessData, OperationError<SetBrightnessError>, MutationVariables<SetBrightnessBody, SetBrightnessParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /** @summary Adjust the the brightness of the light */
        isMutating<TContext>(filters?: MutationFiltersByParameters<SetBrightnessBody, SetBrightnessData, SetBrightnessParameters, OperationError<SetBrightnessError>, TContext> | MutationFiltersByMutationKey<SetBrightnessSchema, SetBrightnessBody, SetBrightnessData, SetBrightnessParameters, OperationError<SetBrightnessError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Adjust the the brightness of the light
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.apiService.setBrightness.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {
         *         path: {
         *             id: id
         *         }
         *     }
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.apiService.setBrightness.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<SetBrightnessBody, SetBrightnessData, SetBrightnessParameters, OperationError<SetBrightnessError>, TContext> | MutationFiltersByMutationKey<SetBrightnessSchema, SetBrightnessBody, SetBrightnessData, SetBrightnessParameters, OperationError<SetBrightnessError>, TContext>): Mutation<SetBrightnessData, SetBrightnessError, MutationVariables<SetBrightnessBody, SetBrightnessParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<SetBrightnessBody, SetBrightnessData, SetBrightnessParameters, OperationError<SetBrightnessError>, TContext> | MutationFiltersByMutationKey<SetBrightnessSchema, SetBrightnessBody, SetBrightnessData, SetBrightnessParameters, OperationError<SetBrightnessError>, TContext>): Array<Mutation<SetBrightnessData, SetBrightnessError, MutationVariables<SetBrightnessBody, SetBrightnessParameters>, TContext>>;
        };
        schema: SetBrightnessSchema;
        types: {
            parameters: SetBrightnessParameters;
            data: SetBrightnessData;
            error: SetBrightnessError;
            body: SetBrightnessBody;
        };
    };
    /** @summary Set a schedule for the light */
    scheduleLight: {
        /** @summary Set a schedule for the light */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<ScheduleLightBody, ScheduleLightParameters, TMeta, TSignal>, client?: (schema: ScheduleLightSchema, options: ServiceOperationMutationFnOptions<ScheduleLightBody, ScheduleLightParameters, TMeta, TSignal>) => Promise<RequestFnResponse<ScheduleLightData, ScheduleLightError>>): Promise<RequestFnResponse<ScheduleLightData, ScheduleLightError>>;
        /** @summary Set a schedule for the light */
        getMutationKey(parameters: DeepReadonly<ScheduleLightParameters> | void): ServiceOperationMutationKey<ScheduleLightSchema, ScheduleLightParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Set a schedule for the light
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.scheduleLight.useMutation({
         *     path: {
         *         id: id
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.scheduleLight.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         id: id
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends ScheduleLightBody, TContext = unknown>(parameters: DeepReadonly<ScheduleLightParameters>, options?: ServiceOperationUseMutationOptions<ScheduleLightSchema, ScheduleLightData, ScheduleLightParameters, TVariables, OperationError<ScheduleLightError>, TContext>): UseMutationResult<ScheduleLightData, OperationError<ScheduleLightError>, TVariables | void, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Set a schedule for the light
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.scheduleLight.useMutation({
         *     path: {
         *         id: id
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.scheduleLight.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         id: id
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<ScheduleLightBody, ScheduleLightParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<ScheduleLightSchema, ScheduleLightData, ScheduleLightParameters, TVariables, OperationError<ScheduleLightError>, TContext>): UseMutationResult<ScheduleLightData, OperationError<ScheduleLightError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Set a schedule for the light
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const scheduleLightTotal = qraft.apiService.scheduleLight.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const scheduleLightTotal = qraft.apiService.scheduleLight.useIsMutating({
         *     parameters: {
         *         path: {
         *             id: id
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<ScheduleLightBody, ScheduleLightData, ScheduleLightParameters, OperationError<ScheduleLightError>, TContext> | MutationFiltersByMutationKey<ScheduleLightSchema, ScheduleLightBody, ScheduleLightData, ScheduleLightParameters, OperationError<ScheduleLightError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Set a schedule for the light
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const scheduleLightPendingMutationVariables = qraft.apiService.scheduleLight.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const scheduleLightMutationData = qraft.apiService.scheduleLight.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 id: id
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<ScheduleLightData, OperationError<ScheduleLightError>, MutationVariables<ScheduleLightBody, ScheduleLightParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<ScheduleLightBody, ScheduleLightData, ScheduleLightParameters, OperationError<ScheduleLightError>, TContext> | MutationFiltersByMutationKey<ScheduleLightSchema, ScheduleLightBody, ScheduleLightData, ScheduleLightParameters, OperationError<ScheduleLightError>, TContext>;
            select?: (mutation: Mutation<ScheduleLightData, OperationError<ScheduleLightError>, MutationVariables<ScheduleLightBody, ScheduleLightParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /** @summary Set a schedule for the light */
        isMutating<TContext>(filters?: MutationFiltersByParameters<ScheduleLightBody, ScheduleLightData, ScheduleLightParameters, OperationError<ScheduleLightError>, TContext> | MutationFiltersByMutationKey<ScheduleLightSchema, ScheduleLightBody, ScheduleLightData, ScheduleLightParameters, OperationError<ScheduleLightError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Set a schedule for the light
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.apiService.scheduleLight.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {
         *         path: {
         *             id: id
         *         }
         *     }
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.apiService.scheduleLight.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<ScheduleLightBody, ScheduleLightData, ScheduleLightParameters, OperationError<ScheduleLightError>, TContext> | MutationFiltersByMutationKey<ScheduleLightSchema, ScheduleLightBody, ScheduleLightData, ScheduleLightParameters, OperationError<ScheduleLightError>, TContext>): Mutation<ScheduleLightData, ScheduleLightError, MutationVariables<ScheduleLightBody, ScheduleLightParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<ScheduleLightBody, ScheduleLightData, ScheduleLightParameters, OperationError<ScheduleLightError>, TContext> | MutationFiltersByMutationKey<ScheduleLightSchema, ScheduleLightBody, ScheduleLightData, ScheduleLightParameters, OperationError<ScheduleLightError>, TContext>): Array<Mutation<ScheduleLightData, ScheduleLightError, MutationVariables<ScheduleLightBody, ScheduleLightParameters>, TContext>>;
        };
        schema: ScheduleLightSchema;
        types: {
            parameters: ScheduleLightParameters;
            data: ScheduleLightData;
            error: ScheduleLightError;
            body: ScheduleLightBody;
        };
    };
    /** @summary Set a schedule for the irrigation */
    scheduleIrrigation: {
        /** @summary Set a schedule for the irrigation */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<ScheduleIrrigationBody, ScheduleIrrigationParameters, TMeta, TSignal>, client?: (schema: ScheduleIrrigationSchema, options: ServiceOperationMutationFnOptions<ScheduleIrrigationBody, ScheduleIrrigationParameters, TMeta, TSignal>) => Promise<RequestFnResponse<ScheduleIrrigationData, ScheduleIrrigationError>>): Promise<RequestFnResponse<ScheduleIrrigationData, ScheduleIrrigationError>>;
        /** @summary Set a schedule for the irrigation */
        getMutationKey(parameters: DeepReadonly<ScheduleIrrigationParameters> | void): ServiceOperationMutationKey<ScheduleIrrigationSchema, ScheduleIrrigationParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Set a schedule for the irrigation
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.scheduleIrrigation.useMutation({
         *     path: {
         *         id: id
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.scheduleIrrigation.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         id: id
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends ScheduleIrrigationBody, TContext = unknown>(parameters: DeepReadonly<ScheduleIrrigationParameters>, options?: ServiceOperationUseMutationOptions<ScheduleIrrigationSchema, ScheduleIrrigationData, ScheduleIrrigationParameters, TVariables, OperationError<ScheduleIrrigationError>, TContext>): UseMutationResult<ScheduleIrrigationData, OperationError<ScheduleIrrigationError>, TVariables | void, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Set a schedule for the irrigation
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.scheduleIrrigation.useMutation({
         *     path: {
         *         id: id
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.scheduleIrrigation.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         id: id
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<ScheduleIrrigationBody, ScheduleIrrigationParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<ScheduleIrrigationSchema, ScheduleIrrigationData, ScheduleIrrigationParameters, TVariables, OperationError<ScheduleIrrigationError>, TContext>): UseMutationResult<ScheduleIrrigationData, OperationError<ScheduleIrrigationError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Set a schedule for the irrigation
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const scheduleIrrigationTotal = qraft.apiService.scheduleIrrigation.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const scheduleIrrigationTotal = qraft.apiService.scheduleIrrigation.useIsMutating({
         *     parameters: {
         *         path: {
         *             id: id
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<ScheduleIrrigationBody, ScheduleIrrigationData, ScheduleIrrigationParameters, OperationError<ScheduleIrrigationError>, TContext> | MutationFiltersByMutationKey<ScheduleIrrigationSchema, ScheduleIrrigationBody, ScheduleIrrigationData, ScheduleIrrigationParameters, OperationError<ScheduleIrrigationError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Set a schedule for the irrigation
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const scheduleIrrigationPendingMutationVariables = qraft.apiService.scheduleIrrigation.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const scheduleIrrigationMutationData = qraft.apiService.scheduleIrrigation.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 id: id
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<ScheduleIrrigationData, OperationError<ScheduleIrrigationError>, MutationVariables<ScheduleIrrigationBody, ScheduleIrrigationParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<ScheduleIrrigationBody, ScheduleIrrigationData, ScheduleIrrigationParameters, OperationError<ScheduleIrrigationError>, TContext> | MutationFiltersByMutationKey<ScheduleIrrigationSchema, ScheduleIrrigationBody, ScheduleIrrigationData, ScheduleIrrigationParameters, OperationError<ScheduleIrrigationError>, TContext>;
            select?: (mutation: Mutation<ScheduleIrrigationData, OperationError<ScheduleIrrigationError>, MutationVariables<ScheduleIrrigationBody, ScheduleIrrigationParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /** @summary Set a schedule for the irrigation */
        isMutating<TContext>(filters?: MutationFiltersByParameters<ScheduleIrrigationBody, ScheduleIrrigationData, ScheduleIrrigationParameters, OperationError<ScheduleIrrigationError>, TContext> | MutationFiltersByMutationKey<ScheduleIrrigationSchema, ScheduleIrrigationBody, ScheduleIrrigationData, ScheduleIrrigationParameters, OperationError<ScheduleIrrigationError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Set a schedule for the irrigation
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.apiService.scheduleIrrigation.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {
         *         path: {
         *             id: id
         *         }
         *     }
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.apiService.scheduleIrrigation.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<ScheduleIrrigationBody, ScheduleIrrigationData, ScheduleIrrigationParameters, OperationError<ScheduleIrrigationError>, TContext> | MutationFiltersByMutationKey<ScheduleIrrigationSchema, ScheduleIrrigationBody, ScheduleIrrigationData, ScheduleIrrigationParameters, OperationError<ScheduleIrrigationError>, TContext>): Mutation<ScheduleIrrigationData, ScheduleIrrigationError, MutationVariables<ScheduleIrrigationBody, ScheduleIrrigationParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<ScheduleIrrigationBody, ScheduleIrrigationData, ScheduleIrrigationParameters, OperationError<ScheduleIrrigationError>, TContext> | MutationFiltersByMutationKey<ScheduleIrrigationSchema, ScheduleIrrigationBody, ScheduleIrrigationData, ScheduleIrrigationParameters, OperationError<ScheduleIrrigationError>, TContext>): Array<Mutation<ScheduleIrrigationData, ScheduleIrrigationError, MutationVariables<ScheduleIrrigationBody, ScheduleIrrigationParameters>, TContext>>;
        };
        schema: ScheduleIrrigationSchema;
        types: {
            parameters: ScheduleIrrigationParameters;
            data: ScheduleIrrigationData;
            error: ScheduleIrrigationError;
            body: ScheduleIrrigationBody;
        };
    };
    /** @summary Get my IP address */
    myIp: {
        /** @summary Get my IP address */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<MyIpSchema, MyIpParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<MyIpParameters, TMeta, TSignal> | void), client?: (schema: MyIpSchema, options: {
            parameters: MyIpParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<MyIpData, MyIpError>>): Promise<RequestFnResponse<MyIpData, MyIpError>>;
        /** @summary Get my IP address */
        getQueryKey(parameters: DeepReadonly<MyIpParameters> | void): ServiceOperationQueryKey<MyIpSchema, MyIpParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get my IP address
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.myIp.useQuery()
         * ```
         */
        useQuery<TData = MyIpData>(parameters: ServiceOperationQueryKey<MyIpSchema, MyIpParameters> | (DeepReadonly<MyIpParameters> | void), options?: Omit<UndefinedInitialDataOptions<MyIpData, MyIpError, TData, ServiceOperationQueryKey<MyIpSchema, MyIpParameters>>, "queryKey">): UseQueryResult<TData, OperationError<MyIpError>>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get my IP address
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.myIp.useQuery()
         * ```
         */
        useQuery<TData = MyIpData>(parameters: ServiceOperationQueryKey<MyIpSchema, MyIpParameters> | (DeepReadonly<MyIpParameters> | void), options: Omit<DefinedInitialDataOptions<MyIpData, MyIpError, TData, ServiceOperationQueryKey<MyIpSchema, MyIpParameters>>, "queryKey">): DefinedUseQueryResult<TData, OperationError<MyIpError>>;
        /** @summary Get my IP address */
        getInfiniteQueryKey(parameters: DeepReadonly<MyIpParameters> | void): ServiceOperationInfiniteQueryKey<MyIpSchema, MyIpParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Get my IP address
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.myIp.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends MyIpParameters, TQueryFnData = MyIpData, TData = OperationInfiniteData<TQueryFnData, MyIpParameters>>(parameters: ServiceOperationInfiniteQueryKey<MyIpSchema, MyIpParameters> | (DeepReadonly<MyIpParameters> | void), options: Omit<UndefinedInitialDataInfiniteOptions<TQueryFnData, MyIpError, TData, ServiceOperationInfiniteQueryKey<MyIpSchema, MyIpParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>): UseInfiniteQueryResult<TData, OperationError<MyIpError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Get my IP address
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.myIp.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends MyIpParameters, TQueryFnData = MyIpData, TData = OperationInfiniteData<TQueryFnData, MyIpParameters>>(parameters: ServiceOperationInfiniteQueryKey<MyIpSchema, MyIpParameters> | (DeepReadonly<MyIpParameters> | void), options: Omit<DefinedInitialDataInfiniteOptions<TQueryFnData, MyIpError, TData, ServiceOperationInfiniteQueryKey<MyIpSchema, MyIpParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<MyIpData, PartialParameters<DeepReadonly<TPageParam>>>): DefinedUseInfiniteQueryResult<TData, OperationError<MyIpError>>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @summary Get my IP address
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const myIpTotal = qraft.apiService.myIp.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<MyIpSchema, MyIpData, TInfinite, MyIpParameters, MyIpError> | QueryFiltersByQueryKey<MyIpSchema, MyIpData, TInfinite, MyIpParameters, MyIpError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary Get my IP address
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const myIpResults = qraft.apiService.myIp.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * myIpResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const myIpCombinedResults = qraft.apiService.myIp.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * myIpCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<MyIpSchema, MyIpParameters, MyIpData, MyIpError>>, TCombinedResult = Array<UseQueryResult<MyIpData, MyIpError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<MyIpData, MyIpError>>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * Performs asynchronous data fetching with Suspense support.
         * Similar to useQuery but integrates with React Suspense for loading states.
         *
         * @summary Get my IP address
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
         * @example Suspense Query without parameters
         * ```ts
         * const data = qraft.apiService.myIp.useSuspenseQuery()
         * ```
         */
        useSuspenseQuery<TData = MyIpData>(parameters: ServiceOperationQueryKey<MyIpSchema, MyIpParameters> | (DeepReadonly<MyIpParameters> | void), options?: Omit<UseSuspenseQueryOptions<MyIpData, MyIpError, TData, ServiceOperationQueryKey<MyIpSchema, MyIpParameters>>, "queryKey">): UseSuspenseQueryResult<TData, OperationError<MyIpError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @summary Get my IP address
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.myIp.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends MyIpParameters, TData = MyIpData>(parameters: ServiceOperationInfiniteQueryKey<MyIpSchema, MyIpParameters> | (DeepReadonly<MyIpParameters> | void), options: Omit<UseSuspenseInfiniteQueryOptions<MyIpData, MyIpError, OperationInfiniteData<TData, MyIpParameters>, ServiceOperationInfiniteQueryKey<MyIpSchema, MyIpParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<MyIpData, PartialParameters<DeepReadonly<TPageParam>>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, MyIpParameters>, OperationError<MyIpError>>;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
         * Similar to useQueries but integrates with React Suspense for loading states.
         *
         * @summary Get my IP address
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
         * @example Basic usage with Suspense
         * ```ts
         * const myIpData = qraft.apiService.myIp.useSuspenseQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * myIpResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example With data transformation using combine
         * ```ts
         * const myIpCombinedData = qraft.apiService.myIp.useSuspenseQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * myIpCombinedData.forEach(data => console.log({ data }));
         * ```
         */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<MyIpSchema, MyIpParameters, MyIpData, MyIpError>>, TCombinedResult = Array<UseSuspenseQueryResult<MyIpData, MyIpError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<MyIpData, MyIpError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /** @summary Get my IP address */
        fetchQuery(options: ServiceOperationFetchQueryOptions<MyIpSchema, MyIpData, MyIpParameters, MyIpError> | void): Promise<MyIpData>;
        /** @summary Get my IP address */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<MyIpSchema, MyIpData, MyIpParameters, MyIpError> | void): Promise<void>;
        /** @summary Get my IP address */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<MyIpSchema, MyIpData, MyIpParameters, MyIpError> | void): Promise<MyIpData>;
        /** @summary Get my IP address */
        fetchInfiniteQuery<TPageParam extends MyIpParameters>(options: ServiceOperationFetchInfiniteQueryOptions<MyIpSchema, MyIpData, MyIpParameters, DeepReadonly<TPageParam>, MyIpError> | void): Promise<OperationInfiniteData<MyIpData, MyIpParameters>>;
        /** @summary Get my IP address */
        prefetchInfiniteQuery<TPageParam extends MyIpParameters>(options: ServiceOperationFetchInfiniteQueryOptions<MyIpSchema, MyIpData, MyIpParameters, DeepReadonly<TPageParam>, MyIpError> | void): Promise<void>;
        /** @summary Get my IP address */
        ensureInfiniteQueryData<TPageParam extends MyIpParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<MyIpSchema, MyIpData, MyIpParameters, DeepReadonly<TPageParam>, MyIpError> | void): Promise<OperationInfiniteData<MyIpData, MyIpParameters>>;
        /** @summary Get my IP address */
        getQueryData(parameters: ServiceOperationQueryKey<MyIpSchema, MyIpParameters> | (DeepReadonly<MyIpParameters> | void)): MyIpData | undefined;
        /** @summary Get my IP address */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<MyIpSchema, MyIpParameters> | (DeepReadonly<MyIpParameters> | void)): OperationInfiniteData<MyIpData, MyIpParameters> | undefined;
        /** @summary Get my IP address */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<MyIpSchema, MyIpData, TInfinite, MyIpParameters, MyIpError> | QueryFiltersByQueryKey<MyIpSchema, MyIpData, TInfinite, MyIpParameters, MyIpError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<MyIpSchema, MyIpParameters>,
            data: NoInfer<OperationInfiniteData<MyIpData, MyIpParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<MyIpSchema, MyIpParameters>,
            data: MyIpData | undefined
        ]>;
        /** @summary Get my IP address */
        getQueryState(parameters: ServiceOperationQueryKey<MyIpSchema, MyIpParameters> | (DeepReadonly<MyIpParameters> | void)): QueryState<MyIpData, MyIpError> | undefined;
        /** @summary Get my IP address */
        getInfiniteQueryState(parameters: DeepReadonly<MyIpParameters> | ServiceOperationInfiniteQueryKey<MyIpSchema, MyIpParameters> | void): QueryState<OperationInfiniteData<MyIpData, MyIpParameters>, MyIpError> | undefined;
        /** @summary Get my IP address */
        setQueryData(parameters: (DeepReadonly<MyIpParameters> | undefined) | ServiceOperationQueryKey<MyIpSchema, MyIpParameters>, updater: Updater<NoInfer<MyIpData> | undefined, NoInfer<DeepReadonly<MyIpData>> | undefined>, options?: SetDataOptions): MyIpData | undefined;
        /** @summary Get my IP address */
        setInfiniteQueryData(parameters: (DeepReadonly<MyIpParameters> | undefined) | ServiceOperationInfiniteQueryKey<MyIpSchema, MyIpParameters>, updater: Updater<NoInfer<OperationInfiniteData<MyIpData, MyIpParameters>> | undefined, NoInfer<DeepReadonly<OperationInfiniteData<MyIpData, MyIpParameters>>> | undefined>, options?: SetDataOptions): OperationInfiniteData<MyIpData, MyIpParameters> | undefined;
        /** @summary Get my IP address */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<MyIpSchema, MyIpData, TInfinite, MyIpParameters, MyIpError> | QueryFiltersByQueryKey<MyIpSchema, MyIpData, TInfinite, MyIpParameters, MyIpError>, updater: Updater<NoInfer<MyIpData> | undefined, NoInfer<MyIpData> | undefined>, options?: SetDataOptions): Array<MyIpData | undefined>;
        /** @summary Get my IP address */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<MyIpSchema, MyIpData, TInfinite, MyIpParameters, MyIpError>, options?: InvalidateOptions): Promise<void>;
        /** @summary Get my IP address */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<MyIpSchema, MyIpData, TInfinite, MyIpParameters, MyIpError> | QueryFiltersByQueryKey<MyIpSchema, MyIpData, TInfinite, MyIpParameters, MyIpError>, options?: RefetchOptions): Promise<void>;
        /** @summary Get my IP address */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<MyIpSchema, MyIpData, TInfinite, MyIpParameters, MyIpError> | QueryFiltersByQueryKey<MyIpSchema, MyIpData, TInfinite, MyIpParameters, MyIpError>, options?: CancelOptions): Promise<void>;
        /** @summary Get my IP address */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<MyIpSchema, MyIpData, TInfinite, MyIpParameters, MyIpError> | QueryFiltersByQueryKey<MyIpSchema, MyIpData, TInfinite, MyIpParameters, MyIpError>): void;
        /** @summary Get my IP address */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<MyIpSchema, MyIpData, TInfinite, MyIpParameters, MyIpError> | QueryFiltersByQueryKey<MyIpSchema, MyIpData, TInfinite, MyIpParameters, MyIpError>, options?: ResetOptions): Promise<void>;
        /** @summary Get my IP address */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<MyIpSchema, MyIpData, TInfinite, MyIpParameters, MyIpError> | QueryFiltersByQueryKey<MyIpSchema, MyIpData, TInfinite, MyIpParameters, MyIpError>): number;
        schema: MyIpSchema;
        types: {
            parameters: MyIpParameters;
            data: MyIpData;
            error: MyIpError;
        };
    };
    /** @summary Get devices that recently announced presence from the same IP */
    localDevices: {
        /** @summary Get devices that recently announced presence from the same IP */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<LocalDevicesSchema, LocalDevicesParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<LocalDevicesParameters, TMeta, TSignal>), client?: (schema: LocalDevicesSchema, options: {
            parameters: LocalDevicesParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<LocalDevicesData, LocalDevicesError>>): Promise<RequestFnResponse<LocalDevicesData, LocalDevicesError>>;
        /** @summary Get devices that recently announced presence from the same IP */
        getQueryKey(parameters: DeepReadonly<LocalDevicesParameters>): ServiceOperationQueryKey<LocalDevicesSchema, LocalDevicesParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get devices that recently announced presence from the same IP
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.localDevices.useQuery({
         *     query: {
         *         ip: ip
         *     }
         * })
         * ```
         */
        useQuery<TData = LocalDevicesData>(parameters: ServiceOperationQueryKey<LocalDevicesSchema, LocalDevicesParameters> | (DeepReadonly<LocalDevicesParameters>), options?: Omit<UndefinedInitialDataOptions<LocalDevicesData, LocalDevicesError, TData, ServiceOperationQueryKey<LocalDevicesSchema, LocalDevicesParameters>>, "queryKey">): UseQueryResult<TData, OperationError<LocalDevicesError>>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get devices that recently announced presence from the same IP
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.localDevices.useQuery({
         *     query: {
         *         ip: ip
         *     }
         * })
         * ```
         */
        useQuery<TData = LocalDevicesData>(parameters: ServiceOperationQueryKey<LocalDevicesSchema, LocalDevicesParameters> | (DeepReadonly<LocalDevicesParameters>), options: Omit<DefinedInitialDataOptions<LocalDevicesData, LocalDevicesError, TData, ServiceOperationQueryKey<LocalDevicesSchema, LocalDevicesParameters>>, "queryKey">): DefinedUseQueryResult<TData, OperationError<LocalDevicesError>>;
        /** @summary Get devices that recently announced presence from the same IP */
        getInfiniteQueryKey(parameters: DeepReadonly<LocalDevicesParameters>): ServiceOperationInfiniteQueryKey<LocalDevicesSchema, LocalDevicesParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Get devices that recently announced presence from the same IP
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.localDevices.useInfiniteQuery({
         *     query: {
         *         ip: ip
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             ip: initialIp
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends LocalDevicesParameters, TQueryFnData = LocalDevicesData, TData = OperationInfiniteData<TQueryFnData, LocalDevicesParameters>>(parameters: ServiceOperationInfiniteQueryKey<LocalDevicesSchema, LocalDevicesParameters> | (DeepReadonly<LocalDevicesParameters>), options: Omit<UndefinedInitialDataInfiniteOptions<TQueryFnData, LocalDevicesError, TData, ServiceOperationInfiniteQueryKey<LocalDevicesSchema, LocalDevicesParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>): UseInfiniteQueryResult<TData, OperationError<LocalDevicesError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Get devices that recently announced presence from the same IP
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.localDevices.useInfiniteQuery({
         *     query: {
         *         ip: ip
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             ip: initialIp
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends LocalDevicesParameters, TQueryFnData = LocalDevicesData, TData = OperationInfiniteData<TQueryFnData, LocalDevicesParameters>>(parameters: ServiceOperationInfiniteQueryKey<LocalDevicesSchema, LocalDevicesParameters> | (DeepReadonly<LocalDevicesParameters>), options: Omit<DefinedInitialDataInfiniteOptions<TQueryFnData, LocalDevicesError, TData, ServiceOperationInfiniteQueryKey<LocalDevicesSchema, LocalDevicesParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<LocalDevicesData, PartialParameters<DeepReadonly<TPageParam>>>): DefinedUseInfiniteQueryResult<TData, OperationError<LocalDevicesError>>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @summary Get devices that recently announced presence from the same IP
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const localDevicesTotal = qraft.apiService.localDevices.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const localDevicesByParametersTotal = qraft.apiService.localDevices.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         query: {
         *             ip: ip
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<LocalDevicesSchema, LocalDevicesData, TInfinite, LocalDevicesParameters, LocalDevicesError> | QueryFiltersByQueryKey<LocalDevicesSchema, LocalDevicesData, TInfinite, LocalDevicesParameters, LocalDevicesError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary Get devices that recently announced presence from the same IP
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const localDevicesResults = qraft.apiService.localDevices.useQueries({
         *     queries: [
         *         {
         *             query: {
         *                 ip: ip1
         *             }
         *         },
         *         {
         *             query: {
         *                 ip: ip2
         *             }
         *         }
         *     ]
         * });
         * localDevicesResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const localDevicesCombinedResults = qraft.apiService.localDevices.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             query: {
         *                 ip: ip1
         *             }
         *         },
         *         {
         *             query: {
         *                 ip: ip2
         *             }
         *         }
         *     ]
         * });
         * localDevicesCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<LocalDevicesSchema, LocalDevicesParameters, LocalDevicesData, LocalDevicesError>>, TCombinedResult = Array<UseQueryResult<LocalDevicesData, LocalDevicesError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<LocalDevicesData, LocalDevicesError>>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * Performs asynchronous data fetching with Suspense support.
         * Similar to useQuery but integrates with React Suspense for loading states.
         *
         * @summary Get devices that recently announced presence from the same IP
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
         * @example Suspense Query with parameters
         * ```ts
         * const data = qraft.apiService.localDevices.useSuspenseQuery({
         *     query: {
         *         ip: ip
         *     }
         * })
         * ```
         */
        useSuspenseQuery<TData = LocalDevicesData>(parameters: ServiceOperationQueryKey<LocalDevicesSchema, LocalDevicesParameters> | (DeepReadonly<LocalDevicesParameters>), options?: Omit<UseSuspenseQueryOptions<LocalDevicesData, LocalDevicesError, TData, ServiceOperationQueryKey<LocalDevicesSchema, LocalDevicesParameters>>, "queryKey">): UseSuspenseQueryResult<TData, OperationError<LocalDevicesError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @summary Get devices that recently announced presence from the same IP
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.localDevices.useSuspenseInfiniteQuery({
         *     query: {
         *         ip: ip
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             ip: initialIp
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends LocalDevicesParameters, TData = LocalDevicesData>(parameters: ServiceOperationInfiniteQueryKey<LocalDevicesSchema, LocalDevicesParameters> | (DeepReadonly<LocalDevicesParameters>), options: Omit<UseSuspenseInfiniteQueryOptions<LocalDevicesData, LocalDevicesError, OperationInfiniteData<TData, LocalDevicesParameters>, ServiceOperationInfiniteQueryKey<LocalDevicesSchema, LocalDevicesParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<LocalDevicesData, PartialParameters<DeepReadonly<TPageParam>>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, LocalDevicesParameters>, OperationError<LocalDevicesError>>;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
         * Similar to useQueries but integrates with React Suspense for loading states.
         *
         * @summary Get devices that recently announced presence from the same IP
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
         * @example Basic usage with Suspense
         * ```ts
         * const localDevicesData = qraft.apiService.localDevices.useSuspenseQueries({
         *     queries: [
         *         {
         *             query: {
         *                 ip: ip1
         *             }
         *         },
         *         {
         *             query: {
         *                 ip: ip2
         *             }
         *         }
         *     ]
         * });
         * localDevicesResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example With data transformation using combine
         * ```ts
         * const localDevicesCombinedData = qraft.apiService.localDevices.useSuspenseQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             query: {
         *                 ip: ip1
         *             }
         *         },
         *         {
         *             query: {
         *                 ip: ip2
         *             }
         *         }
         *     ]
         * });
         * localDevicesCombinedData.forEach(data => console.log({ data }));
         * ```
         */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<LocalDevicesSchema, LocalDevicesParameters, LocalDevicesData, LocalDevicesError>>, TCombinedResult = Array<UseSuspenseQueryResult<LocalDevicesData, LocalDevicesError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<LocalDevicesData, LocalDevicesError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /** @summary Get devices that recently announced presence from the same IP */
        fetchQuery(options: ServiceOperationFetchQueryOptions<LocalDevicesSchema, LocalDevicesData, LocalDevicesParameters, LocalDevicesError>): Promise<LocalDevicesData>;
        /** @summary Get devices that recently announced presence from the same IP */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<LocalDevicesSchema, LocalDevicesData, LocalDevicesParameters, LocalDevicesError>): Promise<void>;
        /** @summary Get devices that recently announced presence from the same IP */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<LocalDevicesSchema, LocalDevicesData, LocalDevicesParameters, LocalDevicesError>): Promise<LocalDevicesData>;
        /** @summary Get devices that recently announced presence from the same IP */
        fetchInfiniteQuery<TPageParam extends LocalDevicesParameters>(options: ServiceOperationFetchInfiniteQueryOptions<LocalDevicesSchema, LocalDevicesData, LocalDevicesParameters, DeepReadonly<TPageParam>, LocalDevicesError>): Promise<OperationInfiniteData<LocalDevicesData, LocalDevicesParameters>>;
        /** @summary Get devices that recently announced presence from the same IP */
        prefetchInfiniteQuery<TPageParam extends LocalDevicesParameters>(options: ServiceOperationFetchInfiniteQueryOptions<LocalDevicesSchema, LocalDevicesData, LocalDevicesParameters, DeepReadonly<TPageParam>, LocalDevicesError>): Promise<void>;
        /** @summary Get devices that recently announced presence from the same IP */
        ensureInfiniteQueryData<TPageParam extends LocalDevicesParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<LocalDevicesSchema, LocalDevicesData, LocalDevicesParameters, DeepReadonly<TPageParam>, LocalDevicesError>): Promise<OperationInfiniteData<LocalDevicesData, LocalDevicesParameters>>;
        /** @summary Get devices that recently announced presence from the same IP */
        getQueryData(parameters: ServiceOperationQueryKey<LocalDevicesSchema, LocalDevicesParameters> | (DeepReadonly<LocalDevicesParameters>)): LocalDevicesData | undefined;
        /** @summary Get devices that recently announced presence from the same IP */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<LocalDevicesSchema, LocalDevicesParameters> | (DeepReadonly<LocalDevicesParameters>)): OperationInfiniteData<LocalDevicesData, LocalDevicesParameters> | undefined;
        /** @summary Get devices that recently announced presence from the same IP */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<LocalDevicesSchema, LocalDevicesData, TInfinite, LocalDevicesParameters, LocalDevicesError> | QueryFiltersByQueryKey<LocalDevicesSchema, LocalDevicesData, TInfinite, LocalDevicesParameters, LocalDevicesError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<LocalDevicesSchema, LocalDevicesParameters>,
            data: NoInfer<OperationInfiniteData<LocalDevicesData, LocalDevicesParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<LocalDevicesSchema, LocalDevicesParameters>,
            data: LocalDevicesData | undefined
        ]>;
        /** @summary Get devices that recently announced presence from the same IP */
        getQueryState(parameters: ServiceOperationQueryKey<LocalDevicesSchema, LocalDevicesParameters> | (DeepReadonly<LocalDevicesParameters>)): QueryState<LocalDevicesData, LocalDevicesError> | undefined;
        /** @summary Get devices that recently announced presence from the same IP */
        getInfiniteQueryState(parameters: DeepReadonly<LocalDevicesParameters> | ServiceOperationInfiniteQueryKey<LocalDevicesSchema, LocalDevicesParameters>): QueryState<OperationInfiniteData<LocalDevicesData, LocalDevicesParameters>, LocalDevicesError> | undefined;
        /** @summary Get devices that recently announced presence from the same IP */
        setQueryData(parameters: (DeepReadonly<LocalDevicesParameters>) | ServiceOperationQueryKey<LocalDevicesSchema, LocalDevicesParameters>, updater: Updater<NoInfer<LocalDevicesData> | undefined, NoInfer<DeepReadonly<LocalDevicesData>> | undefined>, options?: SetDataOptions): LocalDevicesData | undefined;
        /** @summary Get devices that recently announced presence from the same IP */
        setInfiniteQueryData(parameters: (DeepReadonly<LocalDevicesParameters>) | ServiceOperationInfiniteQueryKey<LocalDevicesSchema, LocalDevicesParameters>, updater: Updater<NoInfer<OperationInfiniteData<LocalDevicesData, LocalDevicesParameters>> | undefined, NoInfer<DeepReadonly<OperationInfiniteData<LocalDevicesData, LocalDevicesParameters>>> | undefined>, options?: SetDataOptions): OperationInfiniteData<LocalDevicesData, LocalDevicesParameters> | undefined;
        /** @summary Get devices that recently announced presence from the same IP */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<LocalDevicesSchema, LocalDevicesData, TInfinite, LocalDevicesParameters, LocalDevicesError> | QueryFiltersByQueryKey<LocalDevicesSchema, LocalDevicesData, TInfinite, LocalDevicesParameters, LocalDevicesError>, updater: Updater<NoInfer<LocalDevicesData> | undefined, NoInfer<LocalDevicesData> | undefined>, options?: SetDataOptions): Array<LocalDevicesData | undefined>;
        /** @summary Get devices that recently announced presence from the same IP */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<LocalDevicesSchema, LocalDevicesData, TInfinite, LocalDevicesParameters, LocalDevicesError>, options?: InvalidateOptions): Promise<void>;
        /** @summary Get devices that recently announced presence from the same IP */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<LocalDevicesSchema, LocalDevicesData, TInfinite, LocalDevicesParameters, LocalDevicesError> | QueryFiltersByQueryKey<LocalDevicesSchema, LocalDevicesData, TInfinite, LocalDevicesParameters, LocalDevicesError>, options?: RefetchOptions): Promise<void>;
        /** @summary Get devices that recently announced presence from the same IP */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<LocalDevicesSchema, LocalDevicesData, TInfinite, LocalDevicesParameters, LocalDevicesError> | QueryFiltersByQueryKey<LocalDevicesSchema, LocalDevicesData, TInfinite, LocalDevicesParameters, LocalDevicesError>, options?: CancelOptions): Promise<void>;
        /** @summary Get devices that recently announced presence from the same IP */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<LocalDevicesSchema, LocalDevicesData, TInfinite, LocalDevicesParameters, LocalDevicesError> | QueryFiltersByQueryKey<LocalDevicesSchema, LocalDevicesData, TInfinite, LocalDevicesParameters, LocalDevicesError>): void;
        /** @summary Get devices that recently announced presence from the same IP */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<LocalDevicesSchema, LocalDevicesData, TInfinite, LocalDevicesParameters, LocalDevicesError> | QueryFiltersByQueryKey<LocalDevicesSchema, LocalDevicesData, TInfinite, LocalDevicesParameters, LocalDevicesError>, options?: ResetOptions): Promise<void>;
        /** @summary Get devices that recently announced presence from the same IP */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<LocalDevicesSchema, LocalDevicesData, TInfinite, LocalDevicesParameters, LocalDevicesError> | QueryFiltersByQueryKey<LocalDevicesSchema, LocalDevicesData, TInfinite, LocalDevicesParameters, LocalDevicesError>): number;
        schema: LocalDevicesSchema;
        types: {
            parameters: LocalDevicesParameters;
            data: LocalDevicesData;
            error: LocalDevicesError;
        };
    };
}
/** @summary Register a new device */
export const createDevice = {
    schema: {
        method: "post",
        url: "/api/device/create",
        mediaType: ["application/json"]
    }
} as {
    schema: CreateDeviceSchema;
    [QraftServiceOperationsToken]: ApiService["createDevice"];
};
/** @summary Delete a device */
export const deleteDevice = {
    schema: {
        method: "delete",
        url: "/api/device/{id}"
    }
} as {
    schema: DeleteDeviceSchema;
    [QraftServiceOperationsToken]: ApiService["deleteDevice"];
};
/** @summary Retrieve the latest state for a specific device */
export const deviceState = {
    schema: {
        method: "get",
        url: "/api/device/{id}/state"
    }
} as {
    schema: DeviceStateSchema;
    [QraftServiceOperationsToken]: ApiService["deviceState"];
};
/** @summary List devices */
export const allDevices = {
    schema: {
        method: "get",
        url: "/api/device/all"
    }
} as {
    schema: AllDevicesSchema;
    [QraftServiceOperationsToken]: ApiService["allDevices"];
};
/** @summary Adjust the the brightness of the light */
export const setBrightness = {
    schema: {
        method: "post",
        url: "/api/device/{id}/light/brightness",
        mediaType: ["application/json"]
    }
} as {
    schema: SetBrightnessSchema;
    [QraftServiceOperationsToken]: ApiService["setBrightness"];
};
/** @summary Set a schedule for the light */
export const scheduleLight = {
    schema: {
        method: "post",
        url: "/api/device/{id}/light/schedule",
        mediaType: ["application/json"]
    }
} as {
    schema: ScheduleLightSchema;
    [QraftServiceOperationsToken]: ApiService["scheduleLight"];
};
/** @summary Set a schedule for the irrigation */
export const scheduleIrrigation = {
    schema: {
        method: "post",
        url: "/api/device/{id}/irrigation/schedule",
        mediaType: ["application/json"]
    }
} as {
    schema: ScheduleIrrigationSchema;
    [QraftServiceOperationsToken]: ApiService["scheduleIrrigation"];
};
/** @summary Get my IP address */
export const myIp = {
    schema: {
        method: "get",
        url: "/api/network/my-ip"
    }
} as {
    schema: MyIpSchema;
    [QraftServiceOperationsToken]: ApiService["myIp"];
};
/** @summary Get devices that recently announced presence from the same IP */
export const localDevices = {
    schema: {
        method: "get",
        url: "/api/network/local-devices"
    }
} as {
    schema: LocalDevicesSchema;
    [QraftServiceOperationsToken]: ApiService["localDevices"];
};
export const apiService = {
    createDevice,
    deleteDevice,
    deviceState,
    allDevices,
    setBrightness,
    scheduleLight,
    scheduleIrrigation,
    myIp,
    localDevices
} as const;
type CreateDeviceSchema = {
    method: "post";
    url: "/api/device/create";
    mediaType: [
        "application/json"
    ];
};
type CreateDeviceParameters = {
    query?: never;
    header?: never;
    path?: never;
};
type CreateDeviceData = paths["/api/device/create"]["post"]["responses"]["200"]["content"]["application/json"];
type CreateDeviceError = unknown;
type CreateDeviceBody = NonNullable<paths["/api/device/create"]["post"]["requestBody"]>["content"]["application/json"];
type DeleteDeviceSchema = {
    method: "delete";
    url: "/api/device/{id}";
};
type DeleteDeviceParameters = paths["/api/device/{id}"]["delete"]["parameters"];
type DeleteDeviceData = paths["/api/device/{id}"]["delete"]["responses"]["200"]["content"]["application/json"];
type DeleteDeviceError = null;
type DeleteDeviceBody = undefined;
type DeviceStateSchema = {
    method: "get";
    url: "/api/device/{id}/state";
};
type DeviceStateParameters = paths["/api/device/{id}/state"]["get"]["parameters"];
type DeviceStateData = paths["/api/device/{id}/state"]["get"]["responses"]["200"]["content"]["application/json"];
type DeviceStateError = unknown;
type AllDevicesSchema = {
    method: "get";
    url: "/api/device/all";
};
type AllDevicesParameters = undefined;
type AllDevicesData = paths["/api/device/all"]["get"]["responses"]["200"]["content"]["application/json"];
type AllDevicesError = unknown;
type SetBrightnessSchema = {
    method: "post";
    url: "/api/device/{id}/light/brightness";
    mediaType: [
        "application/json"
    ];
};
type SetBrightnessParameters = paths["/api/device/{id}/light/brightness"]["post"]["parameters"];
type SetBrightnessData = unknown;
type SetBrightnessError = unknown;
type SetBrightnessBody = NonNullable<paths["/api/device/{id}/light/brightness"]["post"]["requestBody"]>["content"]["application/json"];
type ScheduleLightSchema = {
    method: "post";
    url: "/api/device/{id}/light/schedule";
    mediaType: [
        "application/json"
    ];
};
type ScheduleLightParameters = paths["/api/device/{id}/light/schedule"]["post"]["parameters"];
type ScheduleLightData = unknown;
type ScheduleLightError = unknown;
type ScheduleLightBody = NonNullable<paths["/api/device/{id}/light/schedule"]["post"]["requestBody"]>["content"]["application/json"];
type ScheduleIrrigationSchema = {
    method: "post";
    url: "/api/device/{id}/irrigation/schedule";
    mediaType: [
        "application/json"
    ];
};
type ScheduleIrrigationParameters = paths["/api/device/{id}/irrigation/schedule"]["post"]["parameters"];
type ScheduleIrrigationData = unknown;
type ScheduleIrrigationError = unknown;
type ScheduleIrrigationBody = NonNullable<paths["/api/device/{id}/irrigation/schedule"]["post"]["requestBody"]>["content"]["application/json"];
type MyIpSchema = {
    method: "get";
    url: "/api/network/my-ip";
};
type MyIpParameters = undefined;
type MyIpData = paths["/api/network/my-ip"]["get"]["responses"]["200"]["content"]["application/json"];
type MyIpError = unknown;
type LocalDevicesSchema = {
    method: "get";
    url: "/api/network/local-devices";
};
type LocalDevicesParameters = paths["/api/network/local-devices"]["get"]["parameters"];
type LocalDevicesData = paths["/api/network/local-devices"]["get"]["responses"]["200"]["content"]["application/json"];
type LocalDevicesError = unknown;
