/**
 * This file was auto-generated by @openapi-qraft/cli.
 * Do not make direct changes to the file.
 */

import type { paths } from "../schema";
import type { DeepReadonly, InvalidateQueryFilters, MutationFiltersByMutationKey, MutationFiltersByParameters, MutationVariables, OperationError, OperationInfiniteData, PartialParameters, QueryFiltersByParameters, QueryFiltersByQueryKey, QueryFnOptionsByParameters, QueryFnOptionsByQueryKey, RequestFnResponse, ServiceOperationEnsureInfiniteQueryDataOptions, ServiceOperationEnsureQueryDataOptions, ServiceOperationFetchInfiniteQueryOptions, ServiceOperationFetchQueryOptions, ServiceOperationInfiniteQueryKey, ServiceOperationMutationFnOptions, ServiceOperationMutationKey, ServiceOperationQueryKey, ServiceOperationUseMutationOptions, UseQueryOptionsForUseQueries, UseQueryOptionsForUseSuspenseQuery, WithOptional, QraftServiceOperationsToken } from "@openapi-qraft/tanstack-query-react-types";
import type { CancelOptions, DefinedInitialDataInfiniteOptions, DefinedInitialDataOptions, DefinedUseInfiniteQueryResult, DefinedUseQueryResult, InfiniteQueryPageParamsOptions, InvalidateOptions, Mutation, MutationCache, MutationState, NoInfer, QueryState, RefetchOptions, ResetOptions, SetDataOptions, UndefinedInitialDataInfiniteOptions, UndefinedInitialDataOptions, Updater, UseInfiniteQueryResult, UseMutationResult, UseQueryResult, UseSuspenseInfiniteQueryOptions, UseSuspenseInfiniteQueryResult, UseSuspenseQueryOptions, UseSuspenseQueryResult } from "@tanstack/react-query";
export interface ApiService {
    /** @summary Authenticate an existing user */
    login: {
        /** @summary Authenticate an existing user */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<LoginBody, LoginParameters, TMeta, TSignal>, client?: (schema: LoginSchema, options: ServiceOperationMutationFnOptions<LoginBody, LoginParameters, TMeta, TSignal>) => Promise<RequestFnResponse<LoginData, LoginError>>): Promise<RequestFnResponse<LoginData, LoginError>>;
        /** @summary Authenticate an existing user */
        getMutationKey(parameters: DeepReadonly<LoginParameters> | void): ServiceOperationMutationKey<LoginSchema, LoginParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Authenticate an existing user
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.login.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.login.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends LoginBody, TContext = unknown>(parameters: DeepReadonly<LoginParameters>, options?: ServiceOperationUseMutationOptions<LoginSchema, LoginData, LoginParameters, TVariables, OperationError<LoginError>, TContext>): UseMutationResult<LoginData, OperationError<LoginError>, TVariables | void, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Authenticate an existing user
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.login.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.login.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<LoginBody, LoginParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<LoginSchema, LoginData, LoginParameters, TVariables, OperationError<LoginError>, TContext>): UseMutationResult<LoginData, OperationError<LoginError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Authenticate an existing user
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const loginTotal = qraft.apiService.login.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const loginTotal = qraft.apiService.login.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<LoginBody, LoginData, LoginParameters, OperationError<LoginError>, TContext> | MutationFiltersByMutationKey<LoginSchema, LoginBody, LoginData, LoginParameters, OperationError<LoginError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Authenticate an existing user
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const loginPendingMutationVariables = qraft.apiService.login.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const loginMutationData = qraft.apiService.login.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<LoginData, OperationError<LoginError>, MutationVariables<LoginBody, LoginParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<LoginBody, LoginData, LoginParameters, OperationError<LoginError>, TContext> | MutationFiltersByMutationKey<LoginSchema, LoginBody, LoginData, LoginParameters, OperationError<LoginError>, TContext>;
            select?: (mutation: Mutation<LoginData, OperationError<LoginError>, MutationVariables<LoginBody, LoginParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /** @summary Authenticate an existing user */
        isMutating<TContext>(filters?: MutationFiltersByParameters<LoginBody, LoginData, LoginParameters, OperationError<LoginError>, TContext> | MutationFiltersByMutationKey<LoginSchema, LoginBody, LoginData, LoginParameters, OperationError<LoginError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Authenticate an existing user
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.apiService.login.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {}
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.apiService.login.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<LoginBody, LoginData, LoginParameters, OperationError<LoginError>, TContext> | MutationFiltersByMutationKey<LoginSchema, LoginBody, LoginData, LoginParameters, OperationError<LoginError>, TContext>): Mutation<LoginData, LoginError, MutationVariables<LoginBody, LoginParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<LoginBody, LoginData, LoginParameters, OperationError<LoginError>, TContext> | MutationFiltersByMutationKey<LoginSchema, LoginBody, LoginData, LoginParameters, OperationError<LoginError>, TContext>): Array<Mutation<LoginData, LoginError, MutationVariables<LoginBody, LoginParameters>, TContext>>;
        };
        schema: LoginSchema;
        types: {
            parameters: LoginParameters;
            data: LoginData;
            error: LoginError;
            body: LoginBody;
        };
    };
    /** @summary Register a new user */
    signup: {
        /** @summary Register a new user */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<SignupBody, SignupParameters, TMeta, TSignal>, client?: (schema: SignupSchema, options: ServiceOperationMutationFnOptions<SignupBody, SignupParameters, TMeta, TSignal>) => Promise<RequestFnResponse<SignupData, SignupError>>): Promise<RequestFnResponse<SignupData, SignupError>>;
        /** @summary Register a new user */
        getMutationKey(parameters: DeepReadonly<SignupParameters> | void): ServiceOperationMutationKey<SignupSchema, SignupParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Register a new user
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.signup.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.signup.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends SignupBody, TContext = unknown>(parameters: DeepReadonly<SignupParameters>, options?: ServiceOperationUseMutationOptions<SignupSchema, SignupData, SignupParameters, TVariables, OperationError<SignupError>, TContext>): UseMutationResult<SignupData, OperationError<SignupError>, TVariables | void, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Register a new user
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.signup.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.signup.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<SignupBody, SignupParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<SignupSchema, SignupData, SignupParameters, TVariables, OperationError<SignupError>, TContext>): UseMutationResult<SignupData, OperationError<SignupError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Register a new user
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const signupTotal = qraft.apiService.signup.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const signupTotal = qraft.apiService.signup.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<SignupBody, SignupData, SignupParameters, OperationError<SignupError>, TContext> | MutationFiltersByMutationKey<SignupSchema, SignupBody, SignupData, SignupParameters, OperationError<SignupError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Register a new user
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const signupPendingMutationVariables = qraft.apiService.signup.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const signupMutationData = qraft.apiService.signup.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<SignupData, OperationError<SignupError>, MutationVariables<SignupBody, SignupParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<SignupBody, SignupData, SignupParameters, OperationError<SignupError>, TContext> | MutationFiltersByMutationKey<SignupSchema, SignupBody, SignupData, SignupParameters, OperationError<SignupError>, TContext>;
            select?: (mutation: Mutation<SignupData, OperationError<SignupError>, MutationVariables<SignupBody, SignupParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /** @summary Register a new user */
        isMutating<TContext>(filters?: MutationFiltersByParameters<SignupBody, SignupData, SignupParameters, OperationError<SignupError>, TContext> | MutationFiltersByMutationKey<SignupSchema, SignupBody, SignupData, SignupParameters, OperationError<SignupError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Register a new user
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.apiService.signup.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {}
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.apiService.signup.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<SignupBody, SignupData, SignupParameters, OperationError<SignupError>, TContext> | MutationFiltersByMutationKey<SignupSchema, SignupBody, SignupData, SignupParameters, OperationError<SignupError>, TContext>): Mutation<SignupData, SignupError, MutationVariables<SignupBody, SignupParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<SignupBody, SignupData, SignupParameters, OperationError<SignupError>, TContext> | MutationFiltersByMutationKey<SignupSchema, SignupBody, SignupData, SignupParameters, OperationError<SignupError>, TContext>): Array<Mutation<SignupData, SignupError, MutationVariables<SignupBody, SignupParameters>, TContext>>;
        };
        schema: SignupSchema;
        types: {
            parameters: SignupParameters;
            data: SignupData;
            error: SignupError;
            body: SignupBody;
        };
    };
    /** @summary Create a new plant */
    createPlant: {
        /** @summary Create a new plant */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<CreatePlantBody, CreatePlantParameters, TMeta, TSignal>, client?: (schema: CreatePlantSchema, options: ServiceOperationMutationFnOptions<CreatePlantBody, CreatePlantParameters, TMeta, TSignal>) => Promise<RequestFnResponse<CreatePlantData, CreatePlantError>>): Promise<RequestFnResponse<CreatePlantData, CreatePlantError>>;
        /** @summary Create a new plant */
        getMutationKey(parameters: DeepReadonly<CreatePlantParameters> | void): ServiceOperationMutationKey<CreatePlantSchema, CreatePlantParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Create a new plant
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.createPlant.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.createPlant.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends CreatePlantBody, TContext = unknown>(parameters: DeepReadonly<CreatePlantParameters>, options?: ServiceOperationUseMutationOptions<CreatePlantSchema, CreatePlantData, CreatePlantParameters, TVariables, OperationError<CreatePlantError>, TContext>): UseMutationResult<CreatePlantData, OperationError<CreatePlantError>, TVariables | void, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Create a new plant
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.createPlant.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.createPlant.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<CreatePlantBody, CreatePlantParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<CreatePlantSchema, CreatePlantData, CreatePlantParameters, TVariables, OperationError<CreatePlantError>, TContext>): UseMutationResult<CreatePlantData, OperationError<CreatePlantError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Create a new plant
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const createPlantTotal = qraft.apiService.createPlant.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const createPlantTotal = qraft.apiService.createPlant.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<CreatePlantBody, CreatePlantData, CreatePlantParameters, OperationError<CreatePlantError>, TContext> | MutationFiltersByMutationKey<CreatePlantSchema, CreatePlantBody, CreatePlantData, CreatePlantParameters, OperationError<CreatePlantError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Create a new plant
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const createPlantPendingMutationVariables = qraft.apiService.createPlant.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const createPlantMutationData = qraft.apiService.createPlant.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<CreatePlantData, OperationError<CreatePlantError>, MutationVariables<CreatePlantBody, CreatePlantParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<CreatePlantBody, CreatePlantData, CreatePlantParameters, OperationError<CreatePlantError>, TContext> | MutationFiltersByMutationKey<CreatePlantSchema, CreatePlantBody, CreatePlantData, CreatePlantParameters, OperationError<CreatePlantError>, TContext>;
            select?: (mutation: Mutation<CreatePlantData, OperationError<CreatePlantError>, MutationVariables<CreatePlantBody, CreatePlantParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /** @summary Create a new plant */
        isMutating<TContext>(filters?: MutationFiltersByParameters<CreatePlantBody, CreatePlantData, CreatePlantParameters, OperationError<CreatePlantError>, TContext> | MutationFiltersByMutationKey<CreatePlantSchema, CreatePlantBody, CreatePlantData, CreatePlantParameters, OperationError<CreatePlantError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Create a new plant
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.apiService.createPlant.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {}
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.apiService.createPlant.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<CreatePlantBody, CreatePlantData, CreatePlantParameters, OperationError<CreatePlantError>, TContext> | MutationFiltersByMutationKey<CreatePlantSchema, CreatePlantBody, CreatePlantData, CreatePlantParameters, OperationError<CreatePlantError>, TContext>): Mutation<CreatePlantData, CreatePlantError, MutationVariables<CreatePlantBody, CreatePlantParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<CreatePlantBody, CreatePlantData, CreatePlantParameters, OperationError<CreatePlantError>, TContext> | MutationFiltersByMutationKey<CreatePlantSchema, CreatePlantBody, CreatePlantData, CreatePlantParameters, OperationError<CreatePlantError>, TContext>): Array<Mutation<CreatePlantData, CreatePlantError, MutationVariables<CreatePlantBody, CreatePlantParameters>, TContext>>;
        };
        schema: CreatePlantSchema;
        types: {
            parameters: CreatePlantParameters;
            data: CreatePlantData;
            error: CreatePlantError;
            body: CreatePlantBody;
        };
    };
    /** @summary Register a new device */
    createDevice: {
        /** @summary Register a new device */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<CreateDeviceBody, CreateDeviceParameters, TMeta, TSignal>, client?: (schema: CreateDeviceSchema, options: ServiceOperationMutationFnOptions<CreateDeviceBody, CreateDeviceParameters, TMeta, TSignal>) => Promise<RequestFnResponse<CreateDeviceData, CreateDeviceError>>): Promise<RequestFnResponse<CreateDeviceData, CreateDeviceError>>;
        /** @summary Register a new device */
        getMutationKey(parameters: DeepReadonly<CreateDeviceParameters> | void): ServiceOperationMutationKey<CreateDeviceSchema, CreateDeviceParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Register a new device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.createDevice.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.createDevice.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends CreateDeviceBody, TContext = unknown>(parameters: DeepReadonly<CreateDeviceParameters>, options?: ServiceOperationUseMutationOptions<CreateDeviceSchema, CreateDeviceData, CreateDeviceParameters, TVariables, OperationError<CreateDeviceError>, TContext>): UseMutationResult<CreateDeviceData, OperationError<CreateDeviceError>, TVariables | void, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Register a new device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.createDevice.useMutation({})
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.createDevice.useMutation()
         * mutate({
         *     body: bodyPayload
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<CreateDeviceBody, CreateDeviceParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<CreateDeviceSchema, CreateDeviceData, CreateDeviceParameters, TVariables, OperationError<CreateDeviceError>, TContext>): UseMutationResult<CreateDeviceData, OperationError<CreateDeviceError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Register a new device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const createDeviceTotal = qraft.apiService.createDevice.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const createDeviceTotal = qraft.apiService.createDevice.useIsMutating({
         *     parameters: {}
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<CreateDeviceBody, CreateDeviceData, CreateDeviceParameters, OperationError<CreateDeviceError>, TContext> | MutationFiltersByMutationKey<CreateDeviceSchema, CreateDeviceBody, CreateDeviceData, CreateDeviceParameters, OperationError<CreateDeviceError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Register a new device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const createDevicePendingMutationVariables = qraft.apiService.createDevice.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const createDeviceMutationData = qraft.apiService.createDevice.useMutationState({
         *     filters: {
         *         parameters: {}
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<CreateDeviceData, OperationError<CreateDeviceError>, MutationVariables<CreateDeviceBody, CreateDeviceParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<CreateDeviceBody, CreateDeviceData, CreateDeviceParameters, OperationError<CreateDeviceError>, TContext> | MutationFiltersByMutationKey<CreateDeviceSchema, CreateDeviceBody, CreateDeviceData, CreateDeviceParameters, OperationError<CreateDeviceError>, TContext>;
            select?: (mutation: Mutation<CreateDeviceData, OperationError<CreateDeviceError>, MutationVariables<CreateDeviceBody, CreateDeviceParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /** @summary Register a new device */
        isMutating<TContext>(filters?: MutationFiltersByParameters<CreateDeviceBody, CreateDeviceData, CreateDeviceParameters, OperationError<CreateDeviceError>, TContext> | MutationFiltersByMutationKey<CreateDeviceSchema, CreateDeviceBody, CreateDeviceData, CreateDeviceParameters, OperationError<CreateDeviceError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Register a new device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.apiService.createDevice.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {}
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.apiService.createDevice.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<CreateDeviceBody, CreateDeviceData, CreateDeviceParameters, OperationError<CreateDeviceError>, TContext> | MutationFiltersByMutationKey<CreateDeviceSchema, CreateDeviceBody, CreateDeviceData, CreateDeviceParameters, OperationError<CreateDeviceError>, TContext>): Mutation<CreateDeviceData, CreateDeviceError, MutationVariables<CreateDeviceBody, CreateDeviceParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<CreateDeviceBody, CreateDeviceData, CreateDeviceParameters, OperationError<CreateDeviceError>, TContext> | MutationFiltersByMutationKey<CreateDeviceSchema, CreateDeviceBody, CreateDeviceData, CreateDeviceParameters, OperationError<CreateDeviceError>, TContext>): Array<Mutation<CreateDeviceData, CreateDeviceError, MutationVariables<CreateDeviceBody, CreateDeviceParameters>, TContext>>;
        };
        schema: CreateDeviceSchema;
        types: {
            parameters: CreateDeviceParameters;
            data: CreateDeviceData;
            error: CreateDeviceError;
            body: CreateDeviceBody;
        };
    };
    /** @summary Retrieve the latest state for a specific device */
    deviceState: {
        /** @summary Retrieve the latest state for a specific device */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<DeviceStateSchema, DeviceStateParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<DeviceStateParameters, TMeta, TSignal>), client?: (schema: DeviceStateSchema, options: {
            parameters: DeviceStateParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<DeviceStateData, DeviceStateError>>): Promise<RequestFnResponse<DeviceStateData, DeviceStateError>>;
        /** @summary Retrieve the latest state for a specific device */
        getQueryKey(parameters: DeepReadonly<DeviceStateParameters>): ServiceOperationQueryKey<DeviceStateSchema, DeviceStateParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Retrieve the latest state for a specific device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.deviceState.useQuery({
         *     path: {
         *         id: id
         *     }
         * })
         * ```
         */
        useQuery<TData = DeviceStateData>(parameters: ServiceOperationQueryKey<DeviceStateSchema, DeviceStateParameters> | (DeepReadonly<DeviceStateParameters>), options?: Omit<UndefinedInitialDataOptions<DeviceStateData, DeviceStateError, TData, ServiceOperationQueryKey<DeviceStateSchema, DeviceStateParameters>>, "queryKey">): UseQueryResult<TData, OperationError<DeviceStateError>>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Retrieve the latest state for a specific device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.deviceState.useQuery({
         *     path: {
         *         id: id
         *     }
         * })
         * ```
         */
        useQuery<TData = DeviceStateData>(parameters: ServiceOperationQueryKey<DeviceStateSchema, DeviceStateParameters> | (DeepReadonly<DeviceStateParameters>), options: Omit<DefinedInitialDataOptions<DeviceStateData, DeviceStateError, TData, ServiceOperationQueryKey<DeviceStateSchema, DeviceStateParameters>>, "queryKey">): DefinedUseQueryResult<TData, OperationError<DeviceStateError>>;
        /** @summary Retrieve the latest state for a specific device */
        getInfiniteQueryKey(parameters: DeepReadonly<DeviceStateParameters>): ServiceOperationInfiniteQueryKey<DeviceStateSchema, DeviceStateParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Retrieve the latest state for a specific device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.deviceState.useInfiniteQuery({
         *     path: {
         *         id: id
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends DeviceStateParameters, TQueryFnData = DeviceStateData, TData = OperationInfiniteData<TQueryFnData, DeviceStateParameters>>(parameters: ServiceOperationInfiniteQueryKey<DeviceStateSchema, DeviceStateParameters> | (DeepReadonly<DeviceStateParameters>), options: Omit<UndefinedInitialDataInfiniteOptions<TQueryFnData, DeviceStateError, TData, ServiceOperationInfiniteQueryKey<DeviceStateSchema, DeviceStateParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>): UseInfiniteQueryResult<TData, OperationError<DeviceStateError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Retrieve the latest state for a specific device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.deviceState.useInfiniteQuery({
         *     path: {
         *         id: id
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends DeviceStateParameters, TQueryFnData = DeviceStateData, TData = OperationInfiniteData<TQueryFnData, DeviceStateParameters>>(parameters: ServiceOperationInfiniteQueryKey<DeviceStateSchema, DeviceStateParameters> | (DeepReadonly<DeviceStateParameters>), options: Omit<DefinedInitialDataInfiniteOptions<TQueryFnData, DeviceStateError, TData, ServiceOperationInfiniteQueryKey<DeviceStateSchema, DeviceStateParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<DeviceStateData, PartialParameters<DeepReadonly<TPageParam>>>): DefinedUseInfiniteQueryResult<TData, OperationError<DeviceStateError>>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @summary Retrieve the latest state for a specific device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const deviceStateTotal = qraft.apiService.deviceState.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const deviceStateByParametersTotal = qraft.apiService.deviceState.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         path: {
         *             id: id
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError> | QueryFiltersByQueryKey<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary Retrieve the latest state for a specific device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const deviceStateResults = qraft.apiService.deviceState.useQueries({
         *     queries: [
         *         {
         *             path: {
         *                 id: id1
         *             }
         *         },
         *         {
         *             path: {
         *                 id: id2
         *             }
         *         }
         *     ]
         * });
         * deviceStateResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const deviceStateCombinedResults = qraft.apiService.deviceState.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             path: {
         *                 id: id1
         *             }
         *         },
         *         {
         *             path: {
         *                 id: id2
         *             }
         *         }
         *     ]
         * });
         * deviceStateCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<DeviceStateSchema, DeviceStateParameters, DeviceStateData, DeviceStateError>>, TCombinedResult = Array<UseQueryResult<DeviceStateData, DeviceStateError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<DeviceStateData, DeviceStateError>>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * Performs asynchronous data fetching with Suspense support.
         * Similar to useQuery but integrates with React Suspense for loading states.
         *
         * @summary Retrieve the latest state for a specific device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
         * @example Suspense Query with parameters
         * ```ts
         * const data = qraft.apiService.deviceState.useSuspenseQuery({
         *     path: {
         *         id: id
         *     }
         * })
         * ```
         */
        useSuspenseQuery<TData = DeviceStateData>(parameters: ServiceOperationQueryKey<DeviceStateSchema, DeviceStateParameters> | (DeepReadonly<DeviceStateParameters>), options?: Omit<UseSuspenseQueryOptions<DeviceStateData, DeviceStateError, TData, ServiceOperationQueryKey<DeviceStateSchema, DeviceStateParameters>>, "queryKey">): UseSuspenseQueryResult<TData, OperationError<DeviceStateError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @summary Retrieve the latest state for a specific device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.deviceState.useSuspenseInfiniteQuery({
         *     path: {
         *         id: id
         *     }
         * }, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends DeviceStateParameters, TData = DeviceStateData>(parameters: ServiceOperationInfiniteQueryKey<DeviceStateSchema, DeviceStateParameters> | (DeepReadonly<DeviceStateParameters>), options: Omit<UseSuspenseInfiniteQueryOptions<DeviceStateData, DeviceStateError, OperationInfiniteData<TData, DeviceStateParameters>, ServiceOperationInfiniteQueryKey<DeviceStateSchema, DeviceStateParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<DeviceStateData, PartialParameters<DeepReadonly<TPageParam>>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, DeviceStateParameters>, OperationError<DeviceStateError>>;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
         * Similar to useQueries but integrates with React Suspense for loading states.
         *
         * @summary Retrieve the latest state for a specific device
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
         * @example Basic usage with Suspense
         * ```ts
         * const deviceStateData = qraft.apiService.deviceState.useSuspenseQueries({
         *     queries: [
         *         {
         *             path: {
         *                 id: id1
         *             }
         *         },
         *         {
         *             path: {
         *                 id: id2
         *             }
         *         }
         *     ]
         * });
         * deviceStateResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example With data transformation using combine
         * ```ts
         * const deviceStateCombinedData = qraft.apiService.deviceState.useSuspenseQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             path: {
         *                 id: id1
         *             }
         *         },
         *         {
         *             path: {
         *                 id: id2
         *             }
         *         }
         *     ]
         * });
         * deviceStateCombinedData.forEach(data => console.log({ data }));
         * ```
         */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<DeviceStateSchema, DeviceStateParameters, DeviceStateData, DeviceStateError>>, TCombinedResult = Array<UseSuspenseQueryResult<DeviceStateData, DeviceStateError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<DeviceStateData, DeviceStateError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /** @summary Retrieve the latest state for a specific device */
        fetchQuery(options: ServiceOperationFetchQueryOptions<DeviceStateSchema, DeviceStateData, DeviceStateParameters, DeviceStateError>): Promise<DeviceStateData>;
        /** @summary Retrieve the latest state for a specific device */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<DeviceStateSchema, DeviceStateData, DeviceStateParameters, DeviceStateError>): Promise<void>;
        /** @summary Retrieve the latest state for a specific device */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<DeviceStateSchema, DeviceStateData, DeviceStateParameters, DeviceStateError>): Promise<DeviceStateData>;
        /** @summary Retrieve the latest state for a specific device */
        fetchInfiniteQuery<TPageParam extends DeviceStateParameters>(options: ServiceOperationFetchInfiniteQueryOptions<DeviceStateSchema, DeviceStateData, DeviceStateParameters, DeepReadonly<TPageParam>, DeviceStateError>): Promise<OperationInfiniteData<DeviceStateData, DeviceStateParameters>>;
        /** @summary Retrieve the latest state for a specific device */
        prefetchInfiniteQuery<TPageParam extends DeviceStateParameters>(options: ServiceOperationFetchInfiniteQueryOptions<DeviceStateSchema, DeviceStateData, DeviceStateParameters, DeepReadonly<TPageParam>, DeviceStateError>): Promise<void>;
        /** @summary Retrieve the latest state for a specific device */
        ensureInfiniteQueryData<TPageParam extends DeviceStateParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<DeviceStateSchema, DeviceStateData, DeviceStateParameters, DeepReadonly<TPageParam>, DeviceStateError>): Promise<OperationInfiniteData<DeviceStateData, DeviceStateParameters>>;
        /** @summary Retrieve the latest state for a specific device */
        getQueryData(parameters: ServiceOperationQueryKey<DeviceStateSchema, DeviceStateParameters> | (DeepReadonly<DeviceStateParameters>)): DeviceStateData | undefined;
        /** @summary Retrieve the latest state for a specific device */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<DeviceStateSchema, DeviceStateParameters> | (DeepReadonly<DeviceStateParameters>)): OperationInfiniteData<DeviceStateData, DeviceStateParameters> | undefined;
        /** @summary Retrieve the latest state for a specific device */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError> | QueryFiltersByQueryKey<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<DeviceStateSchema, DeviceStateParameters>,
            data: NoInfer<OperationInfiniteData<DeviceStateData, DeviceStateParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<DeviceStateSchema, DeviceStateParameters>,
            data: DeviceStateData | undefined
        ]>;
        /** @summary Retrieve the latest state for a specific device */
        getQueryState(parameters: ServiceOperationQueryKey<DeviceStateSchema, DeviceStateParameters> | (DeepReadonly<DeviceStateParameters>)): QueryState<DeviceStateData, DeviceStateError> | undefined;
        /** @summary Retrieve the latest state for a specific device */
        getInfiniteQueryState(parameters: DeepReadonly<DeviceStateParameters> | ServiceOperationInfiniteQueryKey<DeviceStateSchema, DeviceStateParameters>): QueryState<OperationInfiniteData<DeviceStateData, DeviceStateParameters>, DeviceStateError> | undefined;
        /** @summary Retrieve the latest state for a specific device */
        setQueryData(parameters: (DeepReadonly<DeviceStateParameters>) | ServiceOperationQueryKey<DeviceStateSchema, DeviceStateParameters>, updater: Updater<NoInfer<DeviceStateData> | undefined, NoInfer<DeepReadonly<DeviceStateData>> | undefined>, options?: SetDataOptions): DeviceStateData | undefined;
        /** @summary Retrieve the latest state for a specific device */
        setInfiniteQueryData(parameters: (DeepReadonly<DeviceStateParameters>) | ServiceOperationInfiniteQueryKey<DeviceStateSchema, DeviceStateParameters>, updater: Updater<NoInfer<OperationInfiniteData<DeviceStateData, DeviceStateParameters>> | undefined, NoInfer<DeepReadonly<OperationInfiniteData<DeviceStateData, DeviceStateParameters>>> | undefined>, options?: SetDataOptions): OperationInfiniteData<DeviceStateData, DeviceStateParameters> | undefined;
        /** @summary Retrieve the latest state for a specific device */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError> | QueryFiltersByQueryKey<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError>, updater: Updater<NoInfer<DeviceStateData> | undefined, NoInfer<DeviceStateData> | undefined>, options?: SetDataOptions): Array<DeviceStateData | undefined>;
        /** @summary Retrieve the latest state for a specific device */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError>, options?: InvalidateOptions): Promise<void>;
        /** @summary Retrieve the latest state for a specific device */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError> | QueryFiltersByQueryKey<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError>, options?: RefetchOptions): Promise<void>;
        /** @summary Retrieve the latest state for a specific device */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError> | QueryFiltersByQueryKey<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError>, options?: CancelOptions): Promise<void>;
        /** @summary Retrieve the latest state for a specific device */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError> | QueryFiltersByQueryKey<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError>): void;
        /** @summary Retrieve the latest state for a specific device */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError> | QueryFiltersByQueryKey<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError>, options?: ResetOptions): Promise<void>;
        /** @summary Retrieve the latest state for a specific device */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError> | QueryFiltersByQueryKey<DeviceStateSchema, DeviceStateData, TInfinite, DeviceStateParameters, DeviceStateError>): number;
        schema: DeviceStateSchema;
        types: {
            parameters: DeviceStateParameters;
            data: DeviceStateData;
            error: DeviceStateError;
        };
    };
    /** @summary List devices */
    allDevices: {
        /** @summary List devices */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<AllDevicesSchema, AllDevicesParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<AllDevicesParameters, TMeta, TSignal> | void), client?: (schema: AllDevicesSchema, options: {
            parameters: AllDevicesParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<AllDevicesData, AllDevicesError>>): Promise<RequestFnResponse<AllDevicesData, AllDevicesError>>;
        /** @summary List devices */
        getQueryKey(parameters: DeepReadonly<AllDevicesParameters> | void): ServiceOperationQueryKey<AllDevicesSchema, AllDevicesParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary List devices
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.allDevices.useQuery()
         * ```
         */
        useQuery<TData = AllDevicesData>(parameters: ServiceOperationQueryKey<AllDevicesSchema, AllDevicesParameters> | (DeepReadonly<AllDevicesParameters> | void), options?: Omit<UndefinedInitialDataOptions<AllDevicesData, AllDevicesError, TData, ServiceOperationQueryKey<AllDevicesSchema, AllDevicesParameters>>, "queryKey">): UseQueryResult<TData, OperationError<AllDevicesError>>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary List devices
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query without parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.allDevices.useQuery()
         * ```
         */
        useQuery<TData = AllDevicesData>(parameters: ServiceOperationQueryKey<AllDevicesSchema, AllDevicesParameters> | (DeepReadonly<AllDevicesParameters> | void), options: Omit<DefinedInitialDataOptions<AllDevicesData, AllDevicesError, TData, ServiceOperationQueryKey<AllDevicesSchema, AllDevicesParameters>>, "queryKey">): DefinedUseQueryResult<TData, OperationError<AllDevicesError>>;
        /** @summary List devices */
        getInfiniteQueryKey(parameters: DeepReadonly<AllDevicesParameters> | void): ServiceOperationInfiniteQueryKey<AllDevicesSchema, AllDevicesParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary List devices
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.allDevices.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends AllDevicesParameters, TQueryFnData = AllDevicesData, TData = OperationInfiniteData<TQueryFnData, AllDevicesParameters>>(parameters: ServiceOperationInfiniteQueryKey<AllDevicesSchema, AllDevicesParameters> | (DeepReadonly<AllDevicesParameters> | void), options: Omit<UndefinedInitialDataInfiniteOptions<TQueryFnData, AllDevicesError, TData, ServiceOperationInfiniteQueryKey<AllDevicesSchema, AllDevicesParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>): UseInfiniteQueryResult<TData, OperationError<AllDevicesError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary List devices
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.allDevices.useInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends AllDevicesParameters, TQueryFnData = AllDevicesData, TData = OperationInfiniteData<TQueryFnData, AllDevicesParameters>>(parameters: ServiceOperationInfiniteQueryKey<AllDevicesSchema, AllDevicesParameters> | (DeepReadonly<AllDevicesParameters> | void), options: Omit<DefinedInitialDataInfiniteOptions<TQueryFnData, AllDevicesError, TData, ServiceOperationInfiniteQueryKey<AllDevicesSchema, AllDevicesParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<AllDevicesData, PartialParameters<DeepReadonly<TPageParam>>>): DefinedUseInfiniteQueryResult<TData, OperationError<AllDevicesError>>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @summary List devices
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const allDevicesTotal = qraft.apiService.allDevices.useIsFetching()
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError> | QueryFiltersByQueryKey<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary List devices
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const allDevicesResults = qraft.apiService.allDevices.useQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * allDevicesResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const allDevicesCombinedResults = qraft.apiService.allDevices.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * allDevicesCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<AllDevicesSchema, AllDevicesParameters, AllDevicesData, AllDevicesError>>, TCombinedResult = Array<UseQueryResult<AllDevicesData, AllDevicesError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<AllDevicesData, AllDevicesError>>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * Performs asynchronous data fetching with Suspense support.
         * Similar to useQuery but integrates with React Suspense for loading states.
         *
         * @summary List devices
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
         * @example Suspense Query without parameters
         * ```ts
         * const data = qraft.apiService.allDevices.useSuspenseQuery()
         * ```
         */
        useSuspenseQuery<TData = AllDevicesData>(parameters: ServiceOperationQueryKey<AllDevicesSchema, AllDevicesParameters> | (DeepReadonly<AllDevicesParameters> | void), options?: Omit<UseSuspenseQueryOptions<AllDevicesData, AllDevicesError, TData, ServiceOperationQueryKey<AllDevicesSchema, AllDevicesParameters>>, "queryKey">): UseSuspenseQueryResult<TData, OperationError<AllDevicesError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @summary List devices
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.allDevices.useSuspenseInfiniteQuery({}, {
         *     initialPageParam: {},
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends AllDevicesParameters, TData = AllDevicesData>(parameters: ServiceOperationInfiniteQueryKey<AllDevicesSchema, AllDevicesParameters> | (DeepReadonly<AllDevicesParameters> | void), options: Omit<UseSuspenseInfiniteQueryOptions<AllDevicesData, AllDevicesError, OperationInfiniteData<TData, AllDevicesParameters>, ServiceOperationInfiniteQueryKey<AllDevicesSchema, AllDevicesParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<AllDevicesData, PartialParameters<DeepReadonly<TPageParam>>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, AllDevicesParameters>, OperationError<AllDevicesError>>;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
         * Similar to useQueries but integrates with React Suspense for loading states.
         *
         * @summary List devices
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
         * @example Basic usage with Suspense
         * ```ts
         * const allDevicesData = qraft.apiService.allDevices.useSuspenseQueries({
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * allDevicesResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example With data transformation using combine
         * ```ts
         * const allDevicesCombinedData = qraft.apiService.allDevices.useSuspenseQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {},
         *         {}
         *     ]
         * });
         * allDevicesCombinedData.forEach(data => console.log({ data }));
         * ```
         */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<AllDevicesSchema, AllDevicesParameters, AllDevicesData, AllDevicesError>>, TCombinedResult = Array<UseSuspenseQueryResult<AllDevicesData, AllDevicesError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<AllDevicesData, AllDevicesError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /** @summary List devices */
        fetchQuery(options: ServiceOperationFetchQueryOptions<AllDevicesSchema, AllDevicesData, AllDevicesParameters, AllDevicesError> | void): Promise<AllDevicesData>;
        /** @summary List devices */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<AllDevicesSchema, AllDevicesData, AllDevicesParameters, AllDevicesError> | void): Promise<void>;
        /** @summary List devices */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<AllDevicesSchema, AllDevicesData, AllDevicesParameters, AllDevicesError> | void): Promise<AllDevicesData>;
        /** @summary List devices */
        fetchInfiniteQuery<TPageParam extends AllDevicesParameters>(options: ServiceOperationFetchInfiniteQueryOptions<AllDevicesSchema, AllDevicesData, AllDevicesParameters, DeepReadonly<TPageParam>, AllDevicesError> | void): Promise<OperationInfiniteData<AllDevicesData, AllDevicesParameters>>;
        /** @summary List devices */
        prefetchInfiniteQuery<TPageParam extends AllDevicesParameters>(options: ServiceOperationFetchInfiniteQueryOptions<AllDevicesSchema, AllDevicesData, AllDevicesParameters, DeepReadonly<TPageParam>, AllDevicesError> | void): Promise<void>;
        /** @summary List devices */
        ensureInfiniteQueryData<TPageParam extends AllDevicesParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<AllDevicesSchema, AllDevicesData, AllDevicesParameters, DeepReadonly<TPageParam>, AllDevicesError> | void): Promise<OperationInfiniteData<AllDevicesData, AllDevicesParameters>>;
        /** @summary List devices */
        getQueryData(parameters: ServiceOperationQueryKey<AllDevicesSchema, AllDevicesParameters> | (DeepReadonly<AllDevicesParameters> | void)): AllDevicesData | undefined;
        /** @summary List devices */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<AllDevicesSchema, AllDevicesParameters> | (DeepReadonly<AllDevicesParameters> | void)): OperationInfiniteData<AllDevicesData, AllDevicesParameters> | undefined;
        /** @summary List devices */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError> | QueryFiltersByQueryKey<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<AllDevicesSchema, AllDevicesParameters>,
            data: NoInfer<OperationInfiniteData<AllDevicesData, AllDevicesParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<AllDevicesSchema, AllDevicesParameters>,
            data: AllDevicesData | undefined
        ]>;
        /** @summary List devices */
        getQueryState(parameters: ServiceOperationQueryKey<AllDevicesSchema, AllDevicesParameters> | (DeepReadonly<AllDevicesParameters> | void)): QueryState<AllDevicesData, AllDevicesError> | undefined;
        /** @summary List devices */
        getInfiniteQueryState(parameters: DeepReadonly<AllDevicesParameters> | ServiceOperationInfiniteQueryKey<AllDevicesSchema, AllDevicesParameters> | void): QueryState<OperationInfiniteData<AllDevicesData, AllDevicesParameters>, AllDevicesError> | undefined;
        /** @summary List devices */
        setQueryData(parameters: (DeepReadonly<AllDevicesParameters> | undefined) | ServiceOperationQueryKey<AllDevicesSchema, AllDevicesParameters>, updater: Updater<NoInfer<AllDevicesData> | undefined, NoInfer<DeepReadonly<AllDevicesData>> | undefined>, options?: SetDataOptions): AllDevicesData | undefined;
        /** @summary List devices */
        setInfiniteQueryData(parameters: (DeepReadonly<AllDevicesParameters> | undefined) | ServiceOperationInfiniteQueryKey<AllDevicesSchema, AllDevicesParameters>, updater: Updater<NoInfer<OperationInfiniteData<AllDevicesData, AllDevicesParameters>> | undefined, NoInfer<DeepReadonly<OperationInfiniteData<AllDevicesData, AllDevicesParameters>>> | undefined>, options?: SetDataOptions): OperationInfiniteData<AllDevicesData, AllDevicesParameters> | undefined;
        /** @summary List devices */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError> | QueryFiltersByQueryKey<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError>, updater: Updater<NoInfer<AllDevicesData> | undefined, NoInfer<AllDevicesData> | undefined>, options?: SetDataOptions): Array<AllDevicesData | undefined>;
        /** @summary List devices */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError>, options?: InvalidateOptions): Promise<void>;
        /** @summary List devices */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError> | QueryFiltersByQueryKey<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError>, options?: RefetchOptions): Promise<void>;
        /** @summary List devices */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError> | QueryFiltersByQueryKey<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError>, options?: CancelOptions): Promise<void>;
        /** @summary List devices */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError> | QueryFiltersByQueryKey<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError>): void;
        /** @summary List devices */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError> | QueryFiltersByQueryKey<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError>, options?: ResetOptions): Promise<void>;
        /** @summary List devices */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError> | QueryFiltersByQueryKey<AllDevicesSchema, AllDevicesData, TInfinite, AllDevicesParameters, AllDevicesError>): number;
        schema: AllDevicesSchema;
        types: {
            parameters: AllDevicesParameters;
            data: AllDevicesData;
            error: AllDevicesError;
        };
    };
    /** @summary Turn left light on/off */
    toggleLeftLight: {
        /** @summary Turn left light on/off */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<ToggleLeftLightBody, ToggleLeftLightParameters, TMeta, TSignal>, client?: (schema: ToggleLeftLightSchema, options: ServiceOperationMutationFnOptions<ToggleLeftLightBody, ToggleLeftLightParameters, TMeta, TSignal>) => Promise<RequestFnResponse<ToggleLeftLightData, ToggleLeftLightError>>): Promise<RequestFnResponse<ToggleLeftLightData, ToggleLeftLightError>>;
        /** @summary Turn left light on/off */
        getMutationKey(parameters: DeepReadonly<ToggleLeftLightParameters> | void): ServiceOperationMutationKey<ToggleLeftLightSchema, ToggleLeftLightParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Turn left light on/off
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.toggleLeftLight.useMutation({
         *     path: {
         *         id: id
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.toggleLeftLight.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         id: id
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends ToggleLeftLightBody, TContext = unknown>(parameters: DeepReadonly<ToggleLeftLightParameters>, options?: ServiceOperationUseMutationOptions<ToggleLeftLightSchema, ToggleLeftLightData, ToggleLeftLightParameters, TVariables, OperationError<ToggleLeftLightError>, TContext>): UseMutationResult<ToggleLeftLightData, OperationError<ToggleLeftLightError>, TVariables | void, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Turn left light on/off
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.toggleLeftLight.useMutation({
         *     path: {
         *         id: id
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.toggleLeftLight.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         id: id
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<ToggleLeftLightBody, ToggleLeftLightParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<ToggleLeftLightSchema, ToggleLeftLightData, ToggleLeftLightParameters, TVariables, OperationError<ToggleLeftLightError>, TContext>): UseMutationResult<ToggleLeftLightData, OperationError<ToggleLeftLightError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Turn left light on/off
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const toggleLeftLightTotal = qraft.apiService.toggleLeftLight.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const toggleLeftLightTotal = qraft.apiService.toggleLeftLight.useIsMutating({
         *     parameters: {
         *         path: {
         *             id: id
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<ToggleLeftLightBody, ToggleLeftLightData, ToggleLeftLightParameters, OperationError<ToggleLeftLightError>, TContext> | MutationFiltersByMutationKey<ToggleLeftLightSchema, ToggleLeftLightBody, ToggleLeftLightData, ToggleLeftLightParameters, OperationError<ToggleLeftLightError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Turn left light on/off
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const toggleLeftLightPendingMutationVariables = qraft.apiService.toggleLeftLight.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const toggleLeftLightMutationData = qraft.apiService.toggleLeftLight.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 id: id
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<ToggleLeftLightData, OperationError<ToggleLeftLightError>, MutationVariables<ToggleLeftLightBody, ToggleLeftLightParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<ToggleLeftLightBody, ToggleLeftLightData, ToggleLeftLightParameters, OperationError<ToggleLeftLightError>, TContext> | MutationFiltersByMutationKey<ToggleLeftLightSchema, ToggleLeftLightBody, ToggleLeftLightData, ToggleLeftLightParameters, OperationError<ToggleLeftLightError>, TContext>;
            select?: (mutation: Mutation<ToggleLeftLightData, OperationError<ToggleLeftLightError>, MutationVariables<ToggleLeftLightBody, ToggleLeftLightParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /** @summary Turn left light on/off */
        isMutating<TContext>(filters?: MutationFiltersByParameters<ToggleLeftLightBody, ToggleLeftLightData, ToggleLeftLightParameters, OperationError<ToggleLeftLightError>, TContext> | MutationFiltersByMutationKey<ToggleLeftLightSchema, ToggleLeftLightBody, ToggleLeftLightData, ToggleLeftLightParameters, OperationError<ToggleLeftLightError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Turn left light on/off
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.apiService.toggleLeftLight.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {
         *         path: {
         *             id: id
         *         }
         *     }
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.apiService.toggleLeftLight.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<ToggleLeftLightBody, ToggleLeftLightData, ToggleLeftLightParameters, OperationError<ToggleLeftLightError>, TContext> | MutationFiltersByMutationKey<ToggleLeftLightSchema, ToggleLeftLightBody, ToggleLeftLightData, ToggleLeftLightParameters, OperationError<ToggleLeftLightError>, TContext>): Mutation<ToggleLeftLightData, ToggleLeftLightError, MutationVariables<ToggleLeftLightBody, ToggleLeftLightParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<ToggleLeftLightBody, ToggleLeftLightData, ToggleLeftLightParameters, OperationError<ToggleLeftLightError>, TContext> | MutationFiltersByMutationKey<ToggleLeftLightSchema, ToggleLeftLightBody, ToggleLeftLightData, ToggleLeftLightParameters, OperationError<ToggleLeftLightError>, TContext>): Array<Mutation<ToggleLeftLightData, ToggleLeftLightError, MutationVariables<ToggleLeftLightBody, ToggleLeftLightParameters>, TContext>>;
        };
        schema: ToggleLeftLightSchema;
        types: {
            parameters: ToggleLeftLightParameters;
            data: ToggleLeftLightData;
            error: ToggleLeftLightError;
            body: ToggleLeftLightBody;
        };
    };
    /** @summary Turn right light on/off */
    toggleRightLight: {
        /** @summary Turn right light on/off */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<ToggleRightLightBody, ToggleRightLightParameters, TMeta, TSignal>, client?: (schema: ToggleRightLightSchema, options: ServiceOperationMutationFnOptions<ToggleRightLightBody, ToggleRightLightParameters, TMeta, TSignal>) => Promise<RequestFnResponse<ToggleRightLightData, ToggleRightLightError>>): Promise<RequestFnResponse<ToggleRightLightData, ToggleRightLightError>>;
        /** @summary Turn right light on/off */
        getMutationKey(parameters: DeepReadonly<ToggleRightLightParameters> | void): ServiceOperationMutationKey<ToggleRightLightSchema, ToggleRightLightParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Turn right light on/off
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.toggleRightLight.useMutation({
         *     path: {
         *         id: id
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.toggleRightLight.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         id: id
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends ToggleRightLightBody, TContext = unknown>(parameters: DeepReadonly<ToggleRightLightParameters>, options?: ServiceOperationUseMutationOptions<ToggleRightLightSchema, ToggleRightLightData, ToggleRightLightParameters, TVariables, OperationError<ToggleRightLightError>, TContext>): UseMutationResult<ToggleRightLightData, OperationError<ToggleRightLightError>, TVariables | void, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Turn right light on/off
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.toggleRightLight.useMutation({
         *     path: {
         *         id: id
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.toggleRightLight.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         id: id
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<ToggleRightLightBody, ToggleRightLightParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<ToggleRightLightSchema, ToggleRightLightData, ToggleRightLightParameters, TVariables, OperationError<ToggleRightLightError>, TContext>): UseMutationResult<ToggleRightLightData, OperationError<ToggleRightLightError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Turn right light on/off
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const toggleRightLightTotal = qraft.apiService.toggleRightLight.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const toggleRightLightTotal = qraft.apiService.toggleRightLight.useIsMutating({
         *     parameters: {
         *         path: {
         *             id: id
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<ToggleRightLightBody, ToggleRightLightData, ToggleRightLightParameters, OperationError<ToggleRightLightError>, TContext> | MutationFiltersByMutationKey<ToggleRightLightSchema, ToggleRightLightBody, ToggleRightLightData, ToggleRightLightParameters, OperationError<ToggleRightLightError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Turn right light on/off
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const toggleRightLightPendingMutationVariables = qraft.apiService.toggleRightLight.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const toggleRightLightMutationData = qraft.apiService.toggleRightLight.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 id: id
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<ToggleRightLightData, OperationError<ToggleRightLightError>, MutationVariables<ToggleRightLightBody, ToggleRightLightParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<ToggleRightLightBody, ToggleRightLightData, ToggleRightLightParameters, OperationError<ToggleRightLightError>, TContext> | MutationFiltersByMutationKey<ToggleRightLightSchema, ToggleRightLightBody, ToggleRightLightData, ToggleRightLightParameters, OperationError<ToggleRightLightError>, TContext>;
            select?: (mutation: Mutation<ToggleRightLightData, OperationError<ToggleRightLightError>, MutationVariables<ToggleRightLightBody, ToggleRightLightParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /** @summary Turn right light on/off */
        isMutating<TContext>(filters?: MutationFiltersByParameters<ToggleRightLightBody, ToggleRightLightData, ToggleRightLightParameters, OperationError<ToggleRightLightError>, TContext> | MutationFiltersByMutationKey<ToggleRightLightSchema, ToggleRightLightBody, ToggleRightLightData, ToggleRightLightParameters, OperationError<ToggleRightLightError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Turn right light on/off
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.apiService.toggleRightLight.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {
         *         path: {
         *             id: id
         *         }
         *     }
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.apiService.toggleRightLight.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<ToggleRightLightBody, ToggleRightLightData, ToggleRightLightParameters, OperationError<ToggleRightLightError>, TContext> | MutationFiltersByMutationKey<ToggleRightLightSchema, ToggleRightLightBody, ToggleRightLightData, ToggleRightLightParameters, OperationError<ToggleRightLightError>, TContext>): Mutation<ToggleRightLightData, ToggleRightLightError, MutationVariables<ToggleRightLightBody, ToggleRightLightParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<ToggleRightLightBody, ToggleRightLightData, ToggleRightLightParameters, OperationError<ToggleRightLightError>, TContext> | MutationFiltersByMutationKey<ToggleRightLightSchema, ToggleRightLightBody, ToggleRightLightData, ToggleRightLightParameters, OperationError<ToggleRightLightError>, TContext>): Array<Mutation<ToggleRightLightData, ToggleRightLightError, MutationVariables<ToggleRightLightBody, ToggleRightLightParameters>, TContext>>;
        };
        schema: ToggleRightLightSchema;
        types: {
            parameters: ToggleRightLightParameters;
            data: ToggleRightLightData;
            error: ToggleRightLightError;
            body: ToggleRightLightBody;
        };
    };
    /** @summary Set a schedule for left light */
    scheduleLeftLight: {
        /** @summary Set a schedule for left light */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<ScheduleLeftLightBody, ScheduleLeftLightParameters, TMeta, TSignal>, client?: (schema: ScheduleLeftLightSchema, options: ServiceOperationMutationFnOptions<ScheduleLeftLightBody, ScheduleLeftLightParameters, TMeta, TSignal>) => Promise<RequestFnResponse<ScheduleLeftLightData, ScheduleLeftLightError>>): Promise<RequestFnResponse<ScheduleLeftLightData, ScheduleLeftLightError>>;
        /** @summary Set a schedule for left light */
        getMutationKey(parameters: DeepReadonly<ScheduleLeftLightParameters> | void): ServiceOperationMutationKey<ScheduleLeftLightSchema, ScheduleLeftLightParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Set a schedule for left light
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.scheduleLeftLight.useMutation({
         *     path: {
         *         id: id
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.scheduleLeftLight.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         id: id
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends ScheduleLeftLightBody, TContext = unknown>(parameters: DeepReadonly<ScheduleLeftLightParameters>, options?: ServiceOperationUseMutationOptions<ScheduleLeftLightSchema, ScheduleLeftLightData, ScheduleLeftLightParameters, TVariables, OperationError<ScheduleLeftLightError>, TContext>): UseMutationResult<ScheduleLeftLightData, OperationError<ScheduleLeftLightError>, TVariables | void, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Set a schedule for left light
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.scheduleLeftLight.useMutation({
         *     path: {
         *         id: id
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.scheduleLeftLight.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         id: id
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<ScheduleLeftLightBody, ScheduleLeftLightParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<ScheduleLeftLightSchema, ScheduleLeftLightData, ScheduleLeftLightParameters, TVariables, OperationError<ScheduleLeftLightError>, TContext>): UseMutationResult<ScheduleLeftLightData, OperationError<ScheduleLeftLightError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Set a schedule for left light
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const scheduleLeftLightTotal = qraft.apiService.scheduleLeftLight.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const scheduleLeftLightTotal = qraft.apiService.scheduleLeftLight.useIsMutating({
         *     parameters: {
         *         path: {
         *             id: id
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<ScheduleLeftLightBody, ScheduleLeftLightData, ScheduleLeftLightParameters, OperationError<ScheduleLeftLightError>, TContext> | MutationFiltersByMutationKey<ScheduleLeftLightSchema, ScheduleLeftLightBody, ScheduleLeftLightData, ScheduleLeftLightParameters, OperationError<ScheduleLeftLightError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Set a schedule for left light
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const scheduleLeftLightPendingMutationVariables = qraft.apiService.scheduleLeftLight.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const scheduleLeftLightMutationData = qraft.apiService.scheduleLeftLight.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 id: id
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<ScheduleLeftLightData, OperationError<ScheduleLeftLightError>, MutationVariables<ScheduleLeftLightBody, ScheduleLeftLightParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<ScheduleLeftLightBody, ScheduleLeftLightData, ScheduleLeftLightParameters, OperationError<ScheduleLeftLightError>, TContext> | MutationFiltersByMutationKey<ScheduleLeftLightSchema, ScheduleLeftLightBody, ScheduleLeftLightData, ScheduleLeftLightParameters, OperationError<ScheduleLeftLightError>, TContext>;
            select?: (mutation: Mutation<ScheduleLeftLightData, OperationError<ScheduleLeftLightError>, MutationVariables<ScheduleLeftLightBody, ScheduleLeftLightParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /** @summary Set a schedule for left light */
        isMutating<TContext>(filters?: MutationFiltersByParameters<ScheduleLeftLightBody, ScheduleLeftLightData, ScheduleLeftLightParameters, OperationError<ScheduleLeftLightError>, TContext> | MutationFiltersByMutationKey<ScheduleLeftLightSchema, ScheduleLeftLightBody, ScheduleLeftLightData, ScheduleLeftLightParameters, OperationError<ScheduleLeftLightError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Set a schedule for left light
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.apiService.scheduleLeftLight.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {
         *         path: {
         *             id: id
         *         }
         *     }
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.apiService.scheduleLeftLight.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<ScheduleLeftLightBody, ScheduleLeftLightData, ScheduleLeftLightParameters, OperationError<ScheduleLeftLightError>, TContext> | MutationFiltersByMutationKey<ScheduleLeftLightSchema, ScheduleLeftLightBody, ScheduleLeftLightData, ScheduleLeftLightParameters, OperationError<ScheduleLeftLightError>, TContext>): Mutation<ScheduleLeftLightData, ScheduleLeftLightError, MutationVariables<ScheduleLeftLightBody, ScheduleLeftLightParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<ScheduleLeftLightBody, ScheduleLeftLightData, ScheduleLeftLightParameters, OperationError<ScheduleLeftLightError>, TContext> | MutationFiltersByMutationKey<ScheduleLeftLightSchema, ScheduleLeftLightBody, ScheduleLeftLightData, ScheduleLeftLightParameters, OperationError<ScheduleLeftLightError>, TContext>): Array<Mutation<ScheduleLeftLightData, ScheduleLeftLightError, MutationVariables<ScheduleLeftLightBody, ScheduleLeftLightParameters>, TContext>>;
        };
        schema: ScheduleLeftLightSchema;
        types: {
            parameters: ScheduleLeftLightParameters;
            data: ScheduleLeftLightData;
            error: ScheduleLeftLightError;
            body: ScheduleLeftLightBody;
        };
    };
    /** @summary Set a schedule for right light */
    scheduleRightLight: {
        /** @summary Set a schedule for right light */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: ServiceOperationMutationFnOptions<ScheduleRightLightBody, ScheduleRightLightParameters, TMeta, TSignal>, client?: (schema: ScheduleRightLightSchema, options: ServiceOperationMutationFnOptions<ScheduleRightLightBody, ScheduleRightLightParameters, TMeta, TSignal>) => Promise<RequestFnResponse<ScheduleRightLightData, ScheduleRightLightError>>): Promise<RequestFnResponse<ScheduleRightLightData, ScheduleRightLightError>>;
        /** @summary Set a schedule for right light */
        getMutationKey(parameters: DeepReadonly<ScheduleRightLightParameters> | void): ServiceOperationMutationKey<ScheduleRightLightSchema, ScheduleRightLightParameters>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Set a schedule for right light
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.scheduleRightLight.useMutation({
         *     path: {
         *         id: id
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.scheduleRightLight.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         id: id
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends ScheduleRightLightBody, TContext = unknown>(parameters: DeepReadonly<ScheduleRightLightParameters>, options?: ServiceOperationUseMutationOptions<ScheduleRightLightSchema, ScheduleRightLightData, ScheduleRightLightParameters, TVariables, OperationError<ScheduleRightLightError>, TContext>): UseMutationResult<ScheduleRightLightData, OperationError<ScheduleRightLightError>, TVariables | void, TContext>;
        /**
         * Enables performing asynchronous data mutation operations such as POST, PUT, PATCH, or DELETE requests.
         * Handles loading state, optimistic updates, and error handling.
         *
         * @summary Set a schedule for right light
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutation|`useMutation(...)` documentation}
         * @example Mutation with predefined parameters, e.g., for updating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.scheduleRightLight.useMutation({
         *     path: {
         *         id: id
         *     }
         * })
         * mutate(body);
         * ```
         * @example Mutation without predefined parameters, e.g., for creating
         * ```ts
         * const { mutate, isPending } = qraft.apiService.scheduleRightLight.useMutation()
         * mutate({
         *     body: bodyPayload,
         *     path: {
         *         id: id
         *     }
         * });
         * ```
         */
        useMutation<TVariables extends MutationVariables<ScheduleRightLightBody, ScheduleRightLightParameters>, TContext = unknown>(parameters: void, options?: ServiceOperationUseMutationOptions<ScheduleRightLightSchema, ScheduleRightLightData, ScheduleRightLightParameters, TVariables, OperationError<ScheduleRightLightError>, TContext>): UseMutationResult<ScheduleRightLightData, OperationError<ScheduleRightLightError>, TVariables, TContext>;
        /**
         * Returns the count of currently in-progress mutations.
         *
         * @summary Set a schedule for right light
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsMutating|`useIsMutating(...)` documentation}
         * @example Check how many mutations are currently in progress for the specified service method.
         * ```ts
         * const scheduleRightLightTotal = qraft.apiService.scheduleRightLight.useIsMutating()
         * ```
         * @example Check how many mutations are currently in progress with the specified parameters.
         * ```ts
         * const scheduleRightLightTotal = qraft.apiService.scheduleRightLight.useIsMutating({
         *     parameters: {
         *         path: {
         *             id: id
         *         }
         *     }
         * })
         * ```
         */
        useIsMutating<TContext = unknown>(filters?: MutationFiltersByParameters<ScheduleRightLightBody, ScheduleRightLightData, ScheduleRightLightParameters, OperationError<ScheduleRightLightError>, TContext> | MutationFiltersByMutationKey<ScheduleRightLightSchema, ScheduleRightLightBody, ScheduleRightLightData, ScheduleRightLightParameters, OperationError<ScheduleRightLightError>, TContext>): number;
        /**
         * Provides access to the current state of a mutation, including its status, any resulting data, and associated errors.
         *
         * @summary Set a schedule for right light
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useMutationState|`useMutationState(...)` documentation}
         * @example Get all variables of all running mutations.
         * ```ts
         * const scheduleRightLightPendingMutationVariables = qraft.apiService.scheduleRightLight.useMutationState({
         *     filters: {
         *         status: "pending"
         *     },
         *     select: mutation => mutation.state.variables
         * })
         * ```
         * @example Get all data for specific mutations via the `parameters`.
         * ```ts
         * const scheduleRightLightMutationData = qraft.apiService.scheduleRightLight.useMutationState({
         *     filters: {
         *         parameters: {
         *             path: {
         *                 id: id
         *             }
         *         }
         *     },
         *     select: mutation => mutation.state.data
         * })
         * ```
         */
        useMutationState<TContext = unknown, TResult = MutationState<ScheduleRightLightData, OperationError<ScheduleRightLightError>, MutationVariables<ScheduleRightLightBody, ScheduleRightLightParameters>, TContext>>(options?: {
            filters?: MutationFiltersByParameters<ScheduleRightLightBody, ScheduleRightLightData, ScheduleRightLightParameters, OperationError<ScheduleRightLightError>, TContext> | MutationFiltersByMutationKey<ScheduleRightLightSchema, ScheduleRightLightBody, ScheduleRightLightData, ScheduleRightLightParameters, OperationError<ScheduleRightLightError>, TContext>;
            select?: (mutation: Mutation<ScheduleRightLightData, OperationError<ScheduleRightLightError>, MutationVariables<ScheduleRightLightBody, ScheduleRightLightParameters>, TContext>) => TResult;
        }): Array<TResult>;
        /** @summary Set a schedule for right light */
        isMutating<TContext>(filters?: MutationFiltersByParameters<ScheduleRightLightBody, ScheduleRightLightData, ScheduleRightLightParameters, OperationError<ScheduleRightLightError>, TContext> | MutationFiltersByMutationKey<ScheduleRightLightSchema, ScheduleRightLightBody, ScheduleRightLightData, ScheduleRightLightParameters, OperationError<ScheduleRightLightError>, TContext>): number;
        /**
         * Returns a `MutationCache` object that provides access to mutation cache operations
         * for the specific endpoint.
         *
         * @summary Set a schedule for right light
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/query-client/getMutationCache|`getMutationCache(...)` documentation}
         *
         * @example Find a mutation with specific parameters
         * ```ts
         * const mutationCache = qraft.apiService.scheduleRightLight.getMutationCache();
         * const mutation = mutationCache.find({
         *     parameters: {
         *         path: {
         *             id: id
         *         }
         *     }
         * });
         * ```
         *
         * @example Find all mutations for the endpoint
         * ```ts
         * const mutationCache = qraft.apiService.scheduleRightLight.getMutationCache();
         * const mutations = mutationCache.findAll();
         * ```
         */
        getMutationCache(): Omit<MutationCache, "find" | "findAll"> & {
            find<TContext = unknown>(filters: MutationFiltersByParameters<ScheduleRightLightBody, ScheduleRightLightData, ScheduleRightLightParameters, OperationError<ScheduleRightLightError>, TContext> | MutationFiltersByMutationKey<ScheduleRightLightSchema, ScheduleRightLightBody, ScheduleRightLightData, ScheduleRightLightParameters, OperationError<ScheduleRightLightError>, TContext>): Mutation<ScheduleRightLightData, ScheduleRightLightError, MutationVariables<ScheduleRightLightBody, ScheduleRightLightParameters>, TContext> | undefined;
            findAll<TContext = unknown>(filters?: MutationFiltersByParameters<ScheduleRightLightBody, ScheduleRightLightData, ScheduleRightLightParameters, OperationError<ScheduleRightLightError>, TContext> | MutationFiltersByMutationKey<ScheduleRightLightSchema, ScheduleRightLightBody, ScheduleRightLightData, ScheduleRightLightParameters, OperationError<ScheduleRightLightError>, TContext>): Array<Mutation<ScheduleRightLightData, ScheduleRightLightError, MutationVariables<ScheduleRightLightBody, ScheduleRightLightParameters>, TContext>>;
        };
        schema: ScheduleRightLightSchema;
        types: {
            parameters: ScheduleRightLightParameters;
            data: ScheduleRightLightData;
            error: ScheduleRightLightError;
            body: ScheduleRightLightBody;
        };
    };
    /** @summary Get devices that recently announced presence from the same IP */
    devicesByIp: {
        /** @summary Get devices that recently announced presence from the same IP */
        <TMeta extends Record<string, any>, TSignal extends AbortSignal = AbortSignal>(options: QueryFnOptionsByQueryKey<DevicesByIpSchema, DevicesByIpParameters, TMeta, TSignal> | (QueryFnOptionsByParameters<DevicesByIpParameters, TMeta, TSignal>), client?: (schema: DevicesByIpSchema, options: {
            parameters: DevicesByIpParameters;
            signal?: TSignal;
            meta?: TMeta;
        }) => Promise<RequestFnResponse<DevicesByIpData, DevicesByIpError>>): Promise<RequestFnResponse<DevicesByIpData, DevicesByIpError>>;
        /** @summary Get devices that recently announced presence from the same IP */
        getQueryKey(parameters: DeepReadonly<DevicesByIpParameters>): ServiceOperationQueryKey<DevicesByIpSchema, DevicesByIpParameters>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get devices that recently announced presence from the same IP
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.devicesByIp.useQuery({
         *     query: {
         *         ip: ip
         *     }
         * })
         * ```
         */
        useQuery<TData = DevicesByIpData>(parameters: ServiceOperationQueryKey<DevicesByIpSchema, DevicesByIpParameters> | (DeepReadonly<DevicesByIpParameters>), options?: Omit<UndefinedInitialDataOptions<DevicesByIpData, DevicesByIpError, TData, ServiceOperationQueryKey<DevicesByIpSchema, DevicesByIpParameters>>, "queryKey">): UseQueryResult<TData, OperationError<DevicesByIpError>>;
        /**
         * Performs asynchronous data fetching, manages loading states and error handling.
         *
         * @summary Get devices that recently announced presence from the same IP
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQuery|`useQuery(...)` documentation}
         * @example Query with parameters
         * ```ts
         * const { data, isLoading } = qraft.apiService.devicesByIp.useQuery({
         *     query: {
         *         ip: ip
         *     }
         * })
         * ```
         */
        useQuery<TData = DevicesByIpData>(parameters: ServiceOperationQueryKey<DevicesByIpSchema, DevicesByIpParameters> | (DeepReadonly<DevicesByIpParameters>), options: Omit<DefinedInitialDataOptions<DevicesByIpData, DevicesByIpError, TData, ServiceOperationQueryKey<DevicesByIpSchema, DevicesByIpParameters>>, "queryKey">): DefinedUseQueryResult<TData, OperationError<DevicesByIpError>>;
        /** @summary Get devices that recently announced presence from the same IP */
        getInfiniteQueryKey(parameters: DeepReadonly<DevicesByIpParameters>): ServiceOperationInfiniteQueryKey<DevicesByIpSchema, DevicesByIpParameters>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Get devices that recently announced presence from the same IP
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.devicesByIp.useInfiniteQuery({
         *     query: {
         *         ip: ip
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             ip: initialIp
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends DevicesByIpParameters, TQueryFnData = DevicesByIpData, TData = OperationInfiniteData<TQueryFnData, DevicesByIpParameters>>(parameters: ServiceOperationInfiniteQueryKey<DevicesByIpSchema, DevicesByIpParameters> | (DeepReadonly<DevicesByIpParameters>), options: Omit<UndefinedInitialDataInfiniteOptions<TQueryFnData, DevicesByIpError, TData, ServiceOperationInfiniteQueryKey<DevicesByIpSchema, DevicesByIpParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<TQueryFnData, PartialParameters<DeepReadonly<TPageParam>>>): UseInfiniteQueryResult<TData, OperationError<DevicesByIpError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         *
         * @summary Get devices that recently announced presence from the same IP
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useInfiniteQuery|`useInfiniteQuery(...)` documentation}
         *
         * @example Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.devicesByIp.useInfiniteQuery({
         *     query: {
         *         ip: ip
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             ip: initialIp
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useInfiniteQuery<TPageParam extends DevicesByIpParameters, TQueryFnData = DevicesByIpData, TData = OperationInfiniteData<TQueryFnData, DevicesByIpParameters>>(parameters: ServiceOperationInfiniteQueryKey<DevicesByIpSchema, DevicesByIpParameters> | (DeepReadonly<DevicesByIpParameters>), options: Omit<DefinedInitialDataInfiniteOptions<TQueryFnData, DevicesByIpError, TData, ServiceOperationInfiniteQueryKey<DevicesByIpSchema, DevicesByIpParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<DevicesByIpData, PartialParameters<DeepReadonly<TPageParam>>>): DefinedUseInfiniteQueryResult<TData, OperationError<DevicesByIpError>>;
        /**
         * Monitors the number of queries currently fetching, matching the provided filters.
         * Useful for creating loading indicators or performing actions based on active requests.
         *
         * @summary Get devices that recently announced presence from the same IP
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useIsFetching|`useIsFetching(...)` documentation}
         * @example Checks the total number of queries fetching from the specified service method,
         * both normal and infinite. If no parameters are provided, no filtering is applied.
         * ```ts
         * const devicesByIpTotal = qraft.apiService.devicesByIp.useIsFetching()
         * ```
         * @example Checks the number of normal queries fetching with the specified parameters.
         * ```ts
         * const devicesByIpByParametersTotal = qraft.apiService.devicesByIp.useIsFetching({
         *     infinite: false,
         *     parameters: {
         *         query: {
         *             ip: ip
         *         }
         *     }
         * })
         * ```
         */
        useIsFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<DevicesByIpSchema, DevicesByIpData, TInfinite, DevicesByIpParameters, DevicesByIpError> | QueryFiltersByQueryKey<DevicesByIpSchema, DevicesByIpData, TInfinite, DevicesByIpParameters, DevicesByIpError>): number;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently. This is especially useful for managing complex data dependencies in parallel.
         *
         * @summary Get devices that recently announced presence from the same IP
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useQueries|`useQueries(...)` documentation}
         * @example Multiple queries. Returns `data`, `error`, `isSuccess` and other properties.
         * ```ts
         * const devicesByIpResults = qraft.apiService.devicesByIp.useQueries({
         *     queries: [
         *         {
         *             query: {
         *                 ip: ip1
         *             }
         *         },
         *         {
         *             query: {
         *                 ip: ip2
         *             }
         *         }
         *     ]
         * });
         * devicesByIpResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example Combined results. Only the data will be returned.
         * ```ts
         * const devicesByIpCombinedResults = qraft.apiService.devicesByIp.useQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             query: {
         *                 ip: ip1
         *             }
         *         },
         *         {
         *             query: {
         *                 ip: ip2
         *             }
         *         }
         *     ]
         * });
         * devicesByIpCombinedResults.forEach(data => console.log({ data }));
         * ```
         */
        useQueries<T extends Array<UseQueryOptionsForUseQueries<DevicesByIpSchema, DevicesByIpParameters, DevicesByIpData, DevicesByIpError>>, TCombinedResult = Array<UseQueryResult<DevicesByIpData, DevicesByIpError>>>(options: {
            queries: T;
            combine?: (results: Array<UseQueryResult<DevicesByIpData, DevicesByIpError>>) => TCombinedResult;
        }): TCombinedResult;
        /**
         * Performs asynchronous data fetching with Suspense support.
         * Similar to useQuery but integrates with React Suspense for loading states.
         *
         * @summary Get devices that recently announced presence from the same IP
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQuery|`useSuspenseQuery(...)` documentation}
         * @example Suspense Query with parameters
         * ```ts
         * const data = qraft.apiService.devicesByIp.useSuspenseQuery({
         *     query: {
         *         ip: ip
         *     }
         * })
         * ```
         */
        useSuspenseQuery<TData = DevicesByIpData>(parameters: ServiceOperationQueryKey<DevicesByIpSchema, DevicesByIpParameters> | (DeepReadonly<DevicesByIpParameters>), options?: Omit<UseSuspenseQueryOptions<DevicesByIpData, DevicesByIpError, TData, ServiceOperationQueryKey<DevicesByIpSchema, DevicesByIpParameters>>, "queryKey">): UseSuspenseQueryResult<TData, OperationError<DevicesByIpError>>;
        /**
         * Performs asynchronous data fetching with support for infinite scrolling scenarios.
         * Manages paginated data and provides utilities for fetching additional pages.
         * It functions similarly to `useInfiniteQuery`, but with added support for React Suspense.
         *
         * @summary Get devices that recently announced presence from the same IP
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseInfiniteQuery|`useSuspenseInfiniteQuery(...)` documentation}
         *
         * @example Suspense Infinite Query
         * ```ts
         * const { data, isLoading, fetchNextPage } = qraft.apiService.devicesByIp.useSuspenseInfiniteQuery({
         *     query: {
         *         ip: ip
         *     }
         * }, {
         *     initialPageParam: {
         *         query: {
         *             ip: initialIp
         *         }
         *     },
         *     getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) => getNextPageParams(lastPage)
         * })
         *
         * console.log(data);
         * fetchNextPage(); // Fetch the next page
         * ```
         */
        useSuspenseInfiniteQuery<TPageParam extends DevicesByIpParameters, TData = DevicesByIpData>(parameters: ServiceOperationInfiniteQueryKey<DevicesByIpSchema, DevicesByIpParameters> | (DeepReadonly<DevicesByIpParameters>), options: Omit<UseSuspenseInfiniteQueryOptions<DevicesByIpData, DevicesByIpError, OperationInfiniteData<TData, DevicesByIpParameters>, ServiceOperationInfiniteQueryKey<DevicesByIpSchema, DevicesByIpParameters>, PartialParameters<DeepReadonly<TPageParam>>>, "queryKey" | "getPreviousPageParam" | "getNextPageParam" | "initialPageParam"> & InfiniteQueryPageParamsOptions<DevicesByIpData, PartialParameters<DeepReadonly<TPageParam>>>): UseSuspenseInfiniteQueryResult<OperationInfiniteData<TData, DevicesByIpParameters>, OperationError<DevicesByIpError>>;
        /**
         * Allows you to execute multiple asynchronous data fetching operations concurrently with Suspense support.
         * Similar to useQueries but integrates with React Suspense for loading states.
         *
         * @summary Get devices that recently announced presence from the same IP
         * @see {@link https://openapi-qraft.github.io/openapi-qraft/docs/hooks/useSuspenseQueries|`useSuspenseQueries(...)` documentation}
         * @example Basic usage with Suspense
         * ```ts
         * const devicesByIpData = qraft.apiService.devicesByIp.useSuspenseQueries({
         *     queries: [
         *         {
         *             query: {
         *                 ip: ip1
         *             }
         *         },
         *         {
         *             query: {
         *                 ip: ip2
         *             }
         *         }
         *     ]
         * });
         * devicesByIpResults.forEach(({ isSuccess, data, error }) => console.log({ isSuccess, data, error }));
         * ```
         * @example With data transformation using combine
         * ```ts
         * const devicesByIpCombinedData = qraft.apiService.devicesByIp.useSuspenseQueries({
         *     combine: results => results.map(result => result.data),
         *     queries: [
         *         {
         *             query: {
         *                 ip: ip1
         *             }
         *         },
         *         {
         *             query: {
         *                 ip: ip2
         *             }
         *         }
         *     ]
         * });
         * devicesByIpCombinedData.forEach(data => console.log({ data }));
         * ```
         */
        useSuspenseQueries<T extends Array<UseQueryOptionsForUseSuspenseQuery<DevicesByIpSchema, DevicesByIpParameters, DevicesByIpData, DevicesByIpError>>, TCombinedResult = Array<UseSuspenseQueryResult<DevicesByIpData, DevicesByIpError>>>(options: {
            queries: T;
            combine?: (results: Array<WithOptional<UseSuspenseQueryResult<DevicesByIpData, DevicesByIpError>, "data">>) => TCombinedResult;
        }): TCombinedResult;
        /** @summary Get devices that recently announced presence from the same IP */
        fetchQuery(options: ServiceOperationFetchQueryOptions<DevicesByIpSchema, DevicesByIpData, DevicesByIpParameters, DevicesByIpError>): Promise<DevicesByIpData>;
        /** @summary Get devices that recently announced presence from the same IP */
        prefetchQuery(options: ServiceOperationFetchQueryOptions<DevicesByIpSchema, DevicesByIpData, DevicesByIpParameters, DevicesByIpError>): Promise<void>;
        /** @summary Get devices that recently announced presence from the same IP */
        ensureQueryData(options: ServiceOperationEnsureQueryDataOptions<DevicesByIpSchema, DevicesByIpData, DevicesByIpParameters, DevicesByIpError>): Promise<DevicesByIpData>;
        /** @summary Get devices that recently announced presence from the same IP */
        fetchInfiniteQuery<TPageParam extends DevicesByIpParameters>(options: ServiceOperationFetchInfiniteQueryOptions<DevicesByIpSchema, DevicesByIpData, DevicesByIpParameters, DeepReadonly<TPageParam>, DevicesByIpError>): Promise<OperationInfiniteData<DevicesByIpData, DevicesByIpParameters>>;
        /** @summary Get devices that recently announced presence from the same IP */
        prefetchInfiniteQuery<TPageParam extends DevicesByIpParameters>(options: ServiceOperationFetchInfiniteQueryOptions<DevicesByIpSchema, DevicesByIpData, DevicesByIpParameters, DeepReadonly<TPageParam>, DevicesByIpError>): Promise<void>;
        /** @summary Get devices that recently announced presence from the same IP */
        ensureInfiniteQueryData<TPageParam extends DevicesByIpParameters>(options: ServiceOperationEnsureInfiniteQueryDataOptions<DevicesByIpSchema, DevicesByIpData, DevicesByIpParameters, DeepReadonly<TPageParam>, DevicesByIpError>): Promise<OperationInfiniteData<DevicesByIpData, DevicesByIpParameters>>;
        /** @summary Get devices that recently announced presence from the same IP */
        getQueryData(parameters: ServiceOperationQueryKey<DevicesByIpSchema, DevicesByIpParameters> | (DeepReadonly<DevicesByIpParameters>)): DevicesByIpData | undefined;
        /** @summary Get devices that recently announced presence from the same IP */
        getInfiniteQueryData(parameters: ServiceOperationInfiniteQueryKey<DevicesByIpSchema, DevicesByIpParameters> | (DeepReadonly<DevicesByIpParameters>)): OperationInfiniteData<DevicesByIpData, DevicesByIpParameters> | undefined;
        /** @summary Get devices that recently announced presence from the same IP */
        getQueriesData<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<DevicesByIpSchema, DevicesByIpData, TInfinite, DevicesByIpParameters, DevicesByIpError> | QueryFiltersByQueryKey<DevicesByIpSchema, DevicesByIpData, TInfinite, DevicesByIpParameters, DevicesByIpError>): TInfinite extends true ? Array<[
            queryKey: ServiceOperationInfiniteQueryKey<DevicesByIpSchema, DevicesByIpParameters>,
            data: NoInfer<OperationInfiniteData<DevicesByIpData, DevicesByIpParameters>> | undefined
        ]> : Array<[
            queryKey: ServiceOperationQueryKey<DevicesByIpSchema, DevicesByIpParameters>,
            data: DevicesByIpData | undefined
        ]>;
        /** @summary Get devices that recently announced presence from the same IP */
        getQueryState(parameters: ServiceOperationQueryKey<DevicesByIpSchema, DevicesByIpParameters> | (DeepReadonly<DevicesByIpParameters>)): QueryState<DevicesByIpData, DevicesByIpError> | undefined;
        /** @summary Get devices that recently announced presence from the same IP */
        getInfiniteQueryState(parameters: DeepReadonly<DevicesByIpParameters> | ServiceOperationInfiniteQueryKey<DevicesByIpSchema, DevicesByIpParameters>): QueryState<OperationInfiniteData<DevicesByIpData, DevicesByIpParameters>, DevicesByIpError> | undefined;
        /** @summary Get devices that recently announced presence from the same IP */
        setQueryData(parameters: (DeepReadonly<DevicesByIpParameters>) | ServiceOperationQueryKey<DevicesByIpSchema, DevicesByIpParameters>, updater: Updater<NoInfer<DevicesByIpData> | undefined, NoInfer<DeepReadonly<DevicesByIpData>> | undefined>, options?: SetDataOptions): DevicesByIpData | undefined;
        /** @summary Get devices that recently announced presence from the same IP */
        setInfiniteQueryData(parameters: (DeepReadonly<DevicesByIpParameters>) | ServiceOperationInfiniteQueryKey<DevicesByIpSchema, DevicesByIpParameters>, updater: Updater<NoInfer<OperationInfiniteData<DevicesByIpData, DevicesByIpParameters>> | undefined, NoInfer<DeepReadonly<OperationInfiniteData<DevicesByIpData, DevicesByIpParameters>>> | undefined>, options?: SetDataOptions): OperationInfiniteData<DevicesByIpData, DevicesByIpParameters> | undefined;
        /** @summary Get devices that recently announced presence from the same IP */
        setQueriesData<TInfinite extends boolean = false>(filters: QueryFiltersByParameters<DevicesByIpSchema, DevicesByIpData, TInfinite, DevicesByIpParameters, DevicesByIpError> | QueryFiltersByQueryKey<DevicesByIpSchema, DevicesByIpData, TInfinite, DevicesByIpParameters, DevicesByIpError>, updater: Updater<NoInfer<DevicesByIpData> | undefined, NoInfer<DevicesByIpData> | undefined>, options?: SetDataOptions): Array<DevicesByIpData | undefined>;
        /** @summary Get devices that recently announced presence from the same IP */
        invalidateQueries<TInfinite extends boolean = false>(filters?: InvalidateQueryFilters<DevicesByIpSchema, DevicesByIpData, TInfinite, DevicesByIpParameters, DevicesByIpError>, options?: InvalidateOptions): Promise<void>;
        /** @summary Get devices that recently announced presence from the same IP */
        refetchQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<DevicesByIpSchema, DevicesByIpData, TInfinite, DevicesByIpParameters, DevicesByIpError> | QueryFiltersByQueryKey<DevicesByIpSchema, DevicesByIpData, TInfinite, DevicesByIpParameters, DevicesByIpError>, options?: RefetchOptions): Promise<void>;
        /** @summary Get devices that recently announced presence from the same IP */
        cancelQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<DevicesByIpSchema, DevicesByIpData, TInfinite, DevicesByIpParameters, DevicesByIpError> | QueryFiltersByQueryKey<DevicesByIpSchema, DevicesByIpData, TInfinite, DevicesByIpParameters, DevicesByIpError>, options?: CancelOptions): Promise<void>;
        /** @summary Get devices that recently announced presence from the same IP */
        removeQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<DevicesByIpSchema, DevicesByIpData, TInfinite, DevicesByIpParameters, DevicesByIpError> | QueryFiltersByQueryKey<DevicesByIpSchema, DevicesByIpData, TInfinite, DevicesByIpParameters, DevicesByIpError>): void;
        /** @summary Get devices that recently announced presence from the same IP */
        resetQueries<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<DevicesByIpSchema, DevicesByIpData, TInfinite, DevicesByIpParameters, DevicesByIpError> | QueryFiltersByQueryKey<DevicesByIpSchema, DevicesByIpData, TInfinite, DevicesByIpParameters, DevicesByIpError>, options?: ResetOptions): Promise<void>;
        /** @summary Get devices that recently announced presence from the same IP */
        isFetching<TInfinite extends boolean = false>(filters?: QueryFiltersByParameters<DevicesByIpSchema, DevicesByIpData, TInfinite, DevicesByIpParameters, DevicesByIpError> | QueryFiltersByQueryKey<DevicesByIpSchema, DevicesByIpData, TInfinite, DevicesByIpParameters, DevicesByIpError>): number;
        schema: DevicesByIpSchema;
        types: {
            parameters: DevicesByIpParameters;
            data: DevicesByIpData;
            error: DevicesByIpError;
        };
    };
}
/** @summary Authenticate an existing user */
export const login = {
    schema: {
        method: "post",
        url: "/api/auth/login",
        mediaType: ["application/json"]
    }
} as {
    schema: LoginSchema;
    [QraftServiceOperationsToken]: ApiService["login"];
};
/** @summary Register a new user */
export const signup = {
    schema: {
        method: "post",
        url: "/api/auth/signup",
        mediaType: ["application/json"]
    }
} as {
    schema: SignupSchema;
    [QraftServiceOperationsToken]: ApiService["signup"];
};
/** @summary Create a new plant */
export const createPlant = {
    schema: {
        method: "post",
        url: "/api/plant/plant/create",
        mediaType: ["application/json"]
    }
} as {
    schema: CreatePlantSchema;
    [QraftServiceOperationsToken]: ApiService["createPlant"];
};
/** @summary Register a new device */
export const createDevice = {
    schema: {
        method: "post",
        url: "/api/device/create",
        mediaType: ["application/json"]
    }
} as {
    schema: CreateDeviceSchema;
    [QraftServiceOperationsToken]: ApiService["createDevice"];
};
/** @summary Retrieve the latest state for a specific device */
export const deviceState = {
    schema: {
        method: "get",
        url: "/api/device/{id}/state"
    }
} as {
    schema: DeviceStateSchema;
    [QraftServiceOperationsToken]: ApiService["deviceState"];
};
/** @summary List devices */
export const allDevices = {
    schema: {
        method: "get",
        url: "/api/device/all"
    }
} as {
    schema: AllDevicesSchema;
    [QraftServiceOperationsToken]: ApiService["allDevices"];
};
/** @summary Turn left light on/off */
export const toggleLeftLight = {
    schema: {
        method: "post",
        url: "/api/device/{id}/left-light/toggle",
        mediaType: ["application/json"]
    }
} as {
    schema: ToggleLeftLightSchema;
    [QraftServiceOperationsToken]: ApiService["toggleLeftLight"];
};
/** @summary Turn right light on/off */
export const toggleRightLight = {
    schema: {
        method: "post",
        url: "/api/device/{id}/right-light/toggle",
        mediaType: ["application/json"]
    }
} as {
    schema: ToggleRightLightSchema;
    [QraftServiceOperationsToken]: ApiService["toggleRightLight"];
};
/** @summary Set a schedule for left light */
export const scheduleLeftLight = {
    schema: {
        method: "post",
        url: "/api/device/{id}/left-light/schedule",
        mediaType: ["application/json"]
    }
} as {
    schema: ScheduleLeftLightSchema;
    [QraftServiceOperationsToken]: ApiService["scheduleLeftLight"];
};
/** @summary Set a schedule for right light */
export const scheduleRightLight = {
    schema: {
        method: "post",
        url: "/api/device/{id}/right-light/schedule",
        mediaType: ["application/json"]
    }
} as {
    schema: ScheduleRightLightSchema;
    [QraftServiceOperationsToken]: ApiService["scheduleRightLight"];
};
/** @summary Get devices that recently announced presence from the same IP */
export const devicesByIp = {
    schema: {
        method: "get",
        url: "/api/device/by-ip"
    }
} as {
    schema: DevicesByIpSchema;
    [QraftServiceOperationsToken]: ApiService["devicesByIp"];
};
export const apiService = {
    login,
    signup,
    createPlant,
    createDevice,
    deviceState,
    allDevices,
    toggleLeftLight,
    toggleRightLight,
    scheduleLeftLight,
    scheduleRightLight,
    devicesByIp
} as const;
type LoginSchema = {
    method: "post";
    url: "/api/auth/login";
    mediaType: [
        "application/json"
    ];
};
type LoginParameters = {
    query?: never;
    header?: never;
    path?: never;
};
type LoginData = paths["/api/auth/login"]["post"]["responses"]["200"]["content"]["application/json"];
type LoginError = unknown;
type LoginBody = NonNullable<paths["/api/auth/login"]["post"]["requestBody"]>["content"]["application/json"];
type SignupSchema = {
    method: "post";
    url: "/api/auth/signup";
    mediaType: [
        "application/json"
    ];
};
type SignupParameters = {
    query?: never;
    header?: never;
    path?: never;
};
type SignupData = paths["/api/auth/signup"]["post"]["responses"]["200"]["content"]["application/json"];
type SignupError = unknown;
type SignupBody = NonNullable<paths["/api/auth/signup"]["post"]["requestBody"]>["content"]["application/json"];
type CreatePlantSchema = {
    method: "post";
    url: "/api/plant/plant/create";
    mediaType: [
        "application/json"
    ];
};
type CreatePlantParameters = {
    query?: never;
    header?: never;
    path?: never;
};
type CreatePlantData = paths["/api/plant/plant/create"]["post"]["responses"]["200"]["content"]["application/json"];
type CreatePlantError = unknown;
type CreatePlantBody = NonNullable<paths["/api/plant/plant/create"]["post"]["requestBody"]>["content"]["application/json"];
type CreateDeviceSchema = {
    method: "post";
    url: "/api/device/create";
    mediaType: [
        "application/json"
    ];
};
type CreateDeviceParameters = {
    query?: never;
    header?: never;
    path?: never;
};
type CreateDeviceData = paths["/api/device/create"]["post"]["responses"]["200"]["content"]["application/json"];
type CreateDeviceError = unknown;
type CreateDeviceBody = NonNullable<paths["/api/device/create"]["post"]["requestBody"]>["content"]["application/json"];
type DeviceStateSchema = {
    method: "get";
    url: "/api/device/{id}/state";
};
type DeviceStateParameters = paths["/api/device/{id}/state"]["get"]["parameters"];
type DeviceStateData = paths["/api/device/{id}/state"]["get"]["responses"]["200"]["content"]["application/json"];
type DeviceStateError = unknown;
type AllDevicesSchema = {
    method: "get";
    url: "/api/device/all";
};
type AllDevicesParameters = undefined;
type AllDevicesData = paths["/api/device/all"]["get"]["responses"]["200"]["content"]["application/json"];
type AllDevicesError = unknown;
type ToggleLeftLightSchema = {
    method: "post";
    url: "/api/device/{id}/left-light/toggle";
    mediaType: [
        "application/json"
    ];
};
type ToggleLeftLightParameters = paths["/api/device/{id}/left-light/toggle"]["post"]["parameters"];
type ToggleLeftLightData = unknown;
type ToggleLeftLightError = unknown;
type ToggleLeftLightBody = NonNullable<paths["/api/device/{id}/left-light/toggle"]["post"]["requestBody"]>["content"]["application/json"];
type ToggleRightLightSchema = {
    method: "post";
    url: "/api/device/{id}/right-light/toggle";
    mediaType: [
        "application/json"
    ];
};
type ToggleRightLightParameters = paths["/api/device/{id}/right-light/toggle"]["post"]["parameters"];
type ToggleRightLightData = unknown;
type ToggleRightLightError = unknown;
type ToggleRightLightBody = NonNullable<paths["/api/device/{id}/right-light/toggle"]["post"]["requestBody"]>["content"]["application/json"];
type ScheduleLeftLightSchema = {
    method: "post";
    url: "/api/device/{id}/left-light/schedule";
    mediaType: [
        "application/json"
    ];
};
type ScheduleLeftLightParameters = paths["/api/device/{id}/left-light/schedule"]["post"]["parameters"];
type ScheduleLeftLightData = unknown;
type ScheduleLeftLightError = unknown;
type ScheduleLeftLightBody = NonNullable<paths["/api/device/{id}/left-light/schedule"]["post"]["requestBody"]>["content"]["application/json"];
type ScheduleRightLightSchema = {
    method: "post";
    url: "/api/device/{id}/right-light/schedule";
    mediaType: [
        "application/json"
    ];
};
type ScheduleRightLightParameters = paths["/api/device/{id}/right-light/schedule"]["post"]["parameters"];
type ScheduleRightLightData = unknown;
type ScheduleRightLightError = unknown;
type ScheduleRightLightBody = NonNullable<paths["/api/device/{id}/right-light/schedule"]["post"]["requestBody"]>["content"]["application/json"];
type DevicesByIpSchema = {
    method: "get";
    url: "/api/device/by-ip";
};
type DevicesByIpParameters = paths["/api/device/by-ip"]["get"]["parameters"];
type DevicesByIpData = unknown;
type DevicesByIpError = unknown;
